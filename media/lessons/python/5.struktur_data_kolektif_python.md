# Struktur Data Kolektif di Python

## Pendahuluan

Python menyediakan **4 tipe data kolektif (collection)** bawaan untuk menyimpan sekumpulan item: **list**, **tuple**, **set**, dan **dictionary**. Masing-masing tipe memiliki karakteristik dan kegunaannya sendiri. Secara umum: 

- **List** – urut (ordered), dapat diubah isinya (*mutable*), dan dapat berisi duplikat.
- **Tuple** – urut (ordered), **tidak dapat diubah** setelah dibuat (*immutable*), dan dapat berisi duplikat.
- **Set** – **tidak urut** (unordered) dan tidak terindeks, *mutable* (dapat diubah dengan menambah/menghapus elemen), **tidak** mengizinkan duplikat.
- **Dictionary (dict)** – kumpulan *key-value* (kunci-nilai) yang urut (insertion ordered), *mutable*, dan **tidak** mengizinkan kunci duplikat (setiap kunci unik mengacu ke sebuah nilai).

> **Catatan:** Menurut dokumentasi Python, *“numbers, strings and tuples are immutable, while dictionaries and lists are mutable.”* Artinya, **list dan dict bisa diubah-ubah isinya** setelah pembuatan, sedangkan **tuple tidak bisa diubah**. (Tipe *set* juga mutable – kita bisa menambah atau menghapus elemen dari set.) Pemahaman tentang sifat *mutable/immutable* ini penting ketika memilih tipe data yang tepat.

Berikut kita bahas masing-masing tipe data kolektif tersebut secara terperinci, dengan contoh kode Python 3.12 beserta penjelasan baris-per-baris dan output yang diharapkan.

## List

### Definisi List dan Karakteristik Utama

**List** adalah struktur data Python yang digunakan untuk menyimpan **sekumpulan item** dalam satu variabel. List ditulis dengan tanda kurung siku `[...]`. Item-item di dalam list **terurut** sesuai urutan penambahannya dan memiliki indeks (posisi) mulai dari 0. List bersifat **mutable** (dapat diubah setelah dibuat), sehingga kita bisa menambah, mengubah, atau menghapus elemen. List juga **mengizinkan duplikat** – artinya nilai yang sama dapat muncul lebih dari sekali di dalam list.

> **Contoh sifat list menurut W3Schools:** *“List items are ordered, changeable, and allow duplicate values.”*. Dengan kata lain, urutan elemen list tetap terjaga, isinya bisa dimodifikasi, dan nilai yang sama boleh berulang.

List cocok digunakan ketika kita membutuhkan **koleksi berurutan** yang elemennya mungkin akan diubah selama program berjalan – misalnya daftar nama pengguna, himpunan angka, dll. 

### Contoh Penggunaan List

Berikut adalah contoh kode yang mendefinisikan sebuah list dan melakukan berbagai operasi dasar pada list: menambah elemen (`append`), menyisipkan elemen pada posisi tertentu (`insert`), menghapus elemen (`remove`), dan mengurutkan elemen (`sort`). Setiap langkah akan dijelaskan:

```python
# Membuat list awal dengan beberapa elemen
fruits = ["apple", "banana", "cherry"]
print("List awal:", fruits)

# Menambahkan item di akhir list
fruits.append("durian")
print("Setelah append:", fruits)

# Menyisipkan item pada indeks ke-1
fruits.insert(1, "blueberry")
print("Setelah insert di index 1:", fruits)

# Menghapus item bernilai "banana" dari list
fruits.remove("banana")
print("Setelah remove 'banana':", fruits)

# Mengurutkan list (secara alfabetis)
fruits.sort()
print("Setelah sort:", fruits)
```

**Penjelasan kode:**

1. `fruits = ["apple", "banana", "cherry"]` – Membuat list bernama `fruits` berisi tiga string. List ditulis dengan `[ ]` dan elemen-elemen dipisahkan koma.
2. `print("List awal:", fruits)` – Mencetak list `fruits` awal. Output menunjukkan seluruh isi list.
3. `fruits.append("durian")` – Menambahkan string `"durian"` ke **akhir** list `fruits` menggunakan metode `.append()`. Metode `append()` akan menambah satu item ke ujung list.
4. `print("Setelah append:", fruits)` – Mencetak isi list `fruits` setelah penambahan. Kita akan melihat `"durian"` muncul di posisi terakhir.
5. `fruits.insert(1, "blueberry")` – Menyisipkan string `"blueberry"` ke dalam list pada **indeks 1** (posisi kedua). Metode `insert(indeks, item)` menyisipkan `item` pada indeks yang ditentukan, dan menggeser elemen setelahnya ke kanan.
6. `print("Setelah insert di index 1:", fruits)` – Mencetak isi list setelah operasi insert. `"blueberry"` sekarang berada di indeks 1, sementara elemen lainnya bergeser.
7. `fruits.remove("banana")` – Menghapus *item* bernilai `"banana"` dari list. Metode `remove(x)` akan menghapus kemunculan pertama dari nilai `x` dalam list. Setelah operasi ini, `"banana"` dihapus.
8. `print("Setelah remove 'banana':", fruits)` – Mencetak isi list setelah menghapus `"banana"`. List kini tidak mengandung nilai tersebut.
9. `fruits.sort()` – Mengurutkan elemen-elemen list *in-place* (langsung mengubah urutan dalam list tersebut). Metode `sort()` secara default mengurutkan list secara **ascending** (menaik) – untuk tipe string, urutan alfabetis A-Z.
10. `print("Setelah sort:", fruits)` – Mencetak isi list setelah pengurutan. Sekarang elemen-elemen `fruits` terurut secara alfabetis.

**Output yang diharapkan:**

```plaintext
List awal: ['apple', 'banana', 'cherry']
Setelah append: ['apple', 'banana', 'cherry', 'durian']
Setelah insert di index 1: ['apple', 'blueberry', 'banana', 'cherry', 'durian']
Setelah remove 'banana': ['apple', 'blueberry', 'cherry', 'durian']
Setelah sort: ['apple', 'blueberry', 'cherry', 'durian']
```

Terlihat bahwa operasi `append` menambah elemen di akhir list, `insert` menyisipkan elemen di posisi tertentu, `remove` menghapus elemen pertama yang nilainya sesuai, dan `sort` mengurutkan list. Karena list bersifat mutable, perubahan-perubahan ini langsung terjadi pada list yang sama.

### Metode Built-in Umum pada List

Python menyediakan banyak metode built-in untuk memanipulasi list. Beberapa metode yang paling umum meliputi:

- **`.append(x)`** – Menambah item `x` ke akhir list.
- **`.insert(i, x)`** – Menyisipkan item `x` pada indeks ke-`i`, menggeser item lama ke kanan.
- **`.remove(x)`** – Menghapus **item pertama** yang bernilai `x` dari list.
- **`.sort()`** – Mengurutkan list secara ascending (menaik) secara default. (Untuk mengurutkan descending, bisa memberikan parameter `reverse=True` atau menggunakan `list.reverse()` setelah sort).
- **`.extend(iterable)`** – Menambahkan semua elemen dari `iterable` (misal list lain) ke akhir list (mirip menggabungkan list).
- **`.pop(i)`** – Menghapus item pada indeks ke-`i` (atau terakhir jika indeks tidak disebutkan) dan mengembalikan item tersebut.
- **`.clear()`** – Mengosongkan seluruh item dalam list (menjadi list kosong).

Anda dapat menemukan daftar lengkap metode list di dokumentasi Python atau sumber seperti W3Schools. Dengan memahami metode-metode ini, manipulasi data dalam list menjadi lebih mudah. Misalnya, `append()` sangat berguna untuk menambah data ke kumpulan, `remove()` untuk menghapus data tertentu, dan `sort()` untuk pengurutan ketika diperlukan.

## Tuple

### Definisi Tuple dan Karakteristik Utama

**Tuple** adalah tipe koleksi yang mirip dengan list (menyimpan sekumpulan item berurutan), namun **bersifat immutable** – sekali tuple dibuat, isinya **tidak dapat diubah** (tidak bisa menambah, menghapus, atau mengubah elemen). Tuple ditulis dengan tanda kurung biasa `(...)`. Seperti list, tuple **terurut** (ordered) dan diindeks (dapat diakses elemen berdasarkan indeks). Tuple juga mengizinkan duplikasi nilai. 

> **Menurut W3Schools:** *“Tuple items are ordered, unchangeable, and allow duplicate values.”*. Jadi, urutan elemen tuple akan tetap, tuple tidak bisa diubah (immutable), tapi nilai yang sama dapat muncul berulang kali.

Karena sifatnya yang immutable, tuple digunakan ketika kita ingin data yang **konstan atau tetap**. Misalnya, tuple cocok untuk menyimpan koordinat (x, y, z), daftar bulan dalam setahun, atau nilai-nilai yang tidak ingin diubah secara tidak sengaja selama program berjalan. Tuple juga sering digunakan untuk **mengemas beberapa nilai** menjadi satu, misalnya nilai kembalian fungsi yang terdiri dari beberapa item.

> **Kapan memilih tuple?** *“You should prefer tuples when you have a fixed collection of items that shouldn’t change, such as coordinates or RGB color values, and when you want to ensure data integrity by preventing modifications.”*. Dengan kata lain, jika kumpulan nilai bersifat tetap dan penting untuk menjaga integritasnya, tuple adalah pilihan yang tepat.

Satu hal penting: untuk membuat tuple dengan **satu elemen saja**, kita tetap harus menuliskan sebuah koma setelah elemen tersebut. Contoh: `singleton = ("apple",)` – tanpa koma, Python akan menganggap `("apple")` sebagai *string* biasa, bukan tuple.

### Contoh Penggunaan Tuple

Berikut contoh kode mendefinisikan tuple dan beberapa operasi akses yang dapat dilakukan (walau tuple tidak bisa diubah, kita bisa membaca isinya, mencari nilai, dll):

```python
# Membuat sebuah tuple
my_tuple = ("apple", "banana", "cherry", "apple")
print("Tuple:", my_tuple)

# Mengakses elemen berdasarkan indeks
print("Elemen pertama:", my_tuple[0])

# Menghitung jumlah kemunculan nilai dalam tuple
print("Jumlah 'apple' dalam tuple:", my_tuple.count("apple"))

# Mencari indeks suatu nilai dalam tuple
print("Index 'banana' dalam tuple:", my_tuple.index("banana"))

# my_tuple[1] = "blueberry"  # contoh: ini akan error karena tuple tidak bisa diubah
```

**Penjelasan kode:**

1. `my_tuple = ("apple", "banana", "cherry", "apple")` – Membuat tuple bernama `my_tuple` dengan empat elemen. Perhatikan bahwa `"apple"` muncul dua kali (duplikat diperbolehkan). Tuple ditulis dengan tanda kurung `( )`. 
2. `print("Tuple:", my_tuple)` – Mencetak keseluruhan tuple. Output menunjukkan tuple dengan sintaks `(…)`.
3. `print("Elemen pertama:", my_tuple[0])` – Mengakses elemen pertama tuple (indeks 0) dan mencetaknya. Ini menunjukkan bahwa kita bisa *read-only* mengambil nilai berdasarkan indeks, sama seperti list.
4. `print("Jumlah 'apple' dalam tuple:", my_tuple.count("apple"))` – Menggunakan metode `.count(x)` untuk menghitung berapa kali nilai `"apple"` muncul dalam `my_tuple`. Metode `.count()` dan `.index()` adalah dua metode built-in pada tuple (kedua metode ini **tidak mengubah tuple**, hanya mengembalikan informasi).
5. `print("Index 'banana' dalam tuple:", my_tuple.index("banana"))` – Menggunakan metode `.index(x)` untuk mendapatkan indeks kemunculan pertama nilai `"banana"` dalam tuple.
6. `# my_tuple[1] = "blueberry"` – Baris ini dikomentari (tidak dieksekusi). Ini contoh percobaan mengubah nilai tuple pada indeks 1. Jika dijalankan, baris ini akan menghasilkan **TypeError** karena tuple bersifat immutable (tidak mendukung item assignment). Kita sengaja tidak mengeksekusinya untuk menghindari error dalam output, namun penting untuk dicatat bahwa operasi ini ilegal pada tuple.

**Output yang diharapkan:**

```plaintext
Tuple: ('apple', 'banana', 'cherry', 'apple')
Elemen pertama: apple
Jumlah 'apple' dalam tuple: 2
Index 'banana' dalam tuple: 1
```

Output menunjukkan isi tuple dan hasil operasi akses. Terlihat bahwa tuple `my_tuple` mengandung dua `"apple"`, sehingga `count("apple")` menghasilkan `2`. Indeks `"banana"` adalah `1` sesuai urutan di tuple. Tidak ada output untuk percobaan modifikasi karena baris tersebut tidak dijalankan – namun jika dicoba, Python akan menampilkan pesan error `'tuple' object does not support item assignment` yang menegaskan bahwa tuple tidak bisa diubah setelah diciptakan.

### Mengakses dan Mengolah Tuple (Meski Immutable)

Walaupun tuple tidak dapat diubah isinya, kita masih bisa **mengakses** elemen-elemennya menggunakan indeks atau melakukan *unpacking* (memecah tuple menjadi beberapa variabel). Contoh unpacking:

```python
coordinates = (10, 20, 30)
x, y, z = coordinates  # unpack tuple into variables
print(x, y, z)  # Output: 10 20 30
```

Jika perlu memodifikasi data yang tersimpan dalam tuple, solusi umumnya adalah **mengkonversi tuple menjadi list**, melakukan perubahan, lalu mengkonversi kembali ke tuple. Contoh pendekatan:

```python
# Misalkan ingin mengubah my_tuple di atas:
temp_list = list(my_tuple)         # ubah tuple menjadi list
temp_list[1] = "blueberry"         # modify the list
my_tuple = tuple(temp_list)        # ubah kembali menjadi tuple
print("Tuple baru:", my_tuple)     # tuple baru dengan perubahan
```

Namun perlu diingat, tuple baru yang dihasilkan berbeda objek dengan tuple awal. Jika tujuan Anda memang sering mengubah data, lebih baik sejak awal gunakan list daripada tuple.

Karena sifat immutability-nya, tuple memiliki **keterbatasan metode**. Selain `.count()` dan `.index()` yang sudah disebut, tidak ada metode seperti `append` atau `remove` pada tuple (karena tidak boleh diubah). Keuntungan immutability adalah keamanan dan integritas data – nilai-nilai di dalam tuple terjamin tidak akan berubah secara tidak sengaja selama program berjalan. Selain itu, tuple dapat digunakan sebagai **kunci dictionary** atau elemen set (sesuatu yang tidak bisa dilakukan list) karena sifatnya yang hashable (immutable).

## Dictionary (Kamus)

### Definisi Dictionary dan Karakteristik Utama

**Dictionary** (atau sering disingkat *dict*) adalah struktur data yang menyimpan pasangan **kunci: nilai** (*key:value pairs*). Setiap item di dalam dict terdiri dari **kunci (key)** dan **nilai (value)**. Dictionary ditulis dengan tanda kurung kurawal `{...}`, dengan format `key: value` untuk setiap pasangan. Contoh: `{"nama": "Ali", "umur": 25}`.

Ciri khas dictionary:
- Setiap **kunci** bersifat **unik** (tidak boleh ada duplikat key). Jika kita menggunakan key yang sama dua kali, nilai yang terakhir akan mengoverride yang sebelumnya.
- Dictionary bersifat **mutable** – kita bisa menambah, mengubah, atau menghapus pasangan kunci-nilai setelah dict dibuat.
- Sejak Python 3.7+, dictionary bersifat **ordered**, artinya urutan penambahan elemen dipertahankan. (Di Python versi lebih lama, dict dianggap tidak terurut. Tetapi dalam Python 3.12, Anda dapat mengasumsikan urutan iterasi dict sesuai urutan memasukkan item.)
- **Tidak mengizinkan duplikat kunci** – meskipun nilai boleh saja duplikat, kunci harus berbeda satu sama lain.

> **Menurut W3Schools:** *“A dictionary is a collection which is ordered*, changeable and do not allow duplicates.”*. Artinya, dict memiliki urutan (pada versi Python terbaru), bisa diubah, dan tidak boleh ada kunci yang sama.

Dictionary sangat berguna untuk melakukan **lookup/pencarian** data secara cepat berdasarkan kunci. Anda bisa membayangkan dictionary seperti **kamus** atau **buku telepon**: kunci adalah kata (atau nama), dan nilai adalah definisi (atau nomor telepon). Dengan mengetahui kunci, kita bisa dengan efisien mendapatkan nilainya tanpa harus menelusuri seluruh koleksi. Operasi pencarian, penambahan, dan penghapusan item pada dict umumnya berkompleksitas *O(1)* rata-rata, berkat implementasi *hash table* di balik layar.

> **Catatan dari Real Python:** *“In Python, dictionaries (or dicts for short) are a central data structure. Dicts store an arbitrary number of objects, each identified by a unique dictionary key. They allow for the efficient lookup, insertion, and deletion of any object associated with a given key.”*. 

Kunci pada dictionary biasanya tipe **string** atau **angka**, tetapi bisa tipe apapun yang bersifat immutable (seperti tuple). Nilainya bisa tipe data apapun (bebas, bahkan bisa list atau dict lain). 

### Contoh Penggunaan Dictionary

Berikut contoh kode untuk dictionary yang memuat beberapa informasi, dan demontrasi operasi umum: mengakses nilai, menambah & mengubah item, menghapus item, serta mendapatkan daftar kunci dan nilai:

```python
# Membuat dictionary dengan beberapa pasangan kunci:nilai
my_dict = {"brand": "Ford", "model": "Mustang", "year": 1964}
print("Dictionary:", my_dict)

# Mengakses nilai berdasarkan kunci
print("Akses nilai 'brand':", my_dict["brand"])
print("Akses nilai 'model' dengan get():", my_dict.get("model"))

# Mengubah nilai pada kunci yang sudah ada
my_dict["year"] = 2020
print("Setelah ubah 'year':", my_dict)

# Menambah pasangan kunci:nilai baru
my_dict["color"] = "red"
print("Setelah menambah 'color':", my_dict)

# Menghapus item berdasarkan kunci
my_dict.pop("model")
print("Setelah pop 'model':", my_dict)

# Melihat semua kunci, nilai, dan pasangan
print("Keys:", my_dict.keys())
print("Values:", my_dict.values())
print("Items:", my_dict.items())
```

**Penjelasan kode:**

1. `my_dict = {"brand": "Ford", "model": "Mustang", "year": 1964}` – Membuat dictionary `my_dict` dengan tiga pasangan kunci:nilai. Di sini `'brand'`, `'model'`, `'year'` adalah keys (tipe string), dan masing-masing memiliki nilai `'Ford'`, `'Mustang'`, `1964`. 
2. `print("Dictionary:", my_dict)` – Mencetak dictionary lengkap. Output akan menampilkan semua pasangan dalam sintaks `{...}`. Perhatikan urutan output sesuai urutan penambahan.
3. `print("Akses nilai 'brand':", my_dict["brand"])` – Mengakses nilai dengan kunci `'brand'` menggunakan notasi indeks `dict[key]`. Ini akan mengembalikan nilai `"Ford"`.
4. `print("Akses nilai 'model' dengan get():", my_dict.get("model"))` – Mengakses nilai dengan kunci `'model'` menggunakan metode `.get(key)`. Hasilnya sama dengan menggunakan indeks biasa, yakni `"Mustang"`. Keuntungan `.get()` adalah jika kunci tidak ada, ia *tidak* menyebabkan error `KeyError` tapi mengembalikan `None` atau nilai default yang kita tentukan.
5. `my_dict["year"] = 2020` – Mengubah nilai untuk kunci `'year'` menjadi `2020`. Karena key `'year'` sudah ada, assignment ini akan **mengganti** nilai lama `1964` dengan `2020`.
6. `print("Setelah ubah 'year':", my_dict)` – Mencetak dictionary setelah perubahan. Terlihat nilai `'year'` kini 2020.
7. `my_dict["color"] = "red"` – Menambah item baru ke dictionary dengan kunci `'color'` dan nilai `"red"`. Key `'color'` sebelumnya belum ada, jadi ini menambahkan pasangan baru ke dict.
8. `print("Setelah menambah 'color':", my_dict)` – Mencetak dictionary setelah penambahan item baru. Kini terdapat empat pasangan kunci:nilai di `my_dict` (brand, model, year, color).
9. `my_dict.pop("model")` – Menghapus item dengan kunci `'model'`. Metode `.pop(key)` akan menghapus item ber-key tersebut dan mengembalikan nilainya (dalam kasus ini akan mengembalikan `"Mustang"`, meskipun kita tidak menyimpannya). Setelah operasi ini, key `'model'` beserta nilainya tidak ada lagi di dictionary.
10. `print("Setelah pop 'model':", my_dict)` – Mencetak dictionary setelah penghapusan. Sekarang `my_dict` hanya berisi kunci `'brand'`, `'year'`, dan `'color'`.
11. `print("Keys:", my_dict.keys())` – Mendapatkan *view* keys dari dictionary menggunakan `.keys()`. Outputnya adalah objek pandangan (*dict_keys*) berisi daftar semua kunci saat ini.
12. `print("Values:", my_dict.values())` – Mendapatkan view untuk semua nilai dalam dictionary dengan `.values()`. Outputnya berupa objek *dict_values*.
13. `print("Items:", my_dict.items())` – Mendapatkan view pasangan *key-value* dengan `.items()`. Hasilnya berupa objek *dict_items* yang berisi tuple-tuple `(key, value)` untuk setiap item.

**Output yang diharapkan:**

```plaintext
Dictionary: {'brand': 'Ford', 'model': 'Mustang', 'year': 1964}
Akses nilai 'brand': Ford
Akses nilai 'model' dengan get(): Mustang
Setelah ubah 'year': {'brand': 'Ford', 'model': 'Mustang', 'year': 2020}
Setelah menambah 'color': {'brand': 'Ford', 'model': 'Mustang', 'year': 2020, 'color': 'red'}
Setelah pop 'model': {'brand': 'Ford', 'year': 2020, 'color': 'red'}
Keys: dict_keys(['brand', 'year', 'color'])
Values: dict_values(['Ford', 2020, 'red'])
Items: dict_items([('brand', 'Ford'), ('year', 2020), ('color', 'red')])
```

Mari kita perhatikan output di atas:

- **Akses nilai:** `'brand'` memberikan `"Ford"`, `'model'` memberikan `"Mustang"`. 
- **Setelah ubah `'year'`:** nilai tahun berubah menjadi 2020.
- **Setelah tambah `'color'`:** pasangan baru `'color': 'red'` muncul.
- **Setelah pop `'model'`:** pasangan dengan key `'model'` hilang dari dict.
- **Keys/Values/Items:** Hasil `my_dict.keys()` adalah `dict_keys(['brand', 'year', 'color'])`. Objek `dict_keys` ini bisa diperlakukan seperti koleksi (bisa di-*iterate* layaknya list). Jika ingin daftar biasa, kita bisa lakukan `list(my_dict.keys())` yang akan menghasilkan `['brand', 'year', 'color']`. Hal yang sama berlaku untuk `values()` dan `items()`. Objek `dict_items([...])` menampilkan setiap pasang kunci-nilai dalam bentuk tuple.

### Operasi dan Metode Umum pada Dictionary

Operasi umum yang sering digunakan pada dict antara lain:

- **Mengakses nilai:** `dict[key]` atau `dict.get(key)` untuk mendapatkan nilai berdasarkan kunci.
- **Menambahkan / Memperbarui:** `dict[new_key] = value` untuk menambah item baru, atau mengubah nilai item ber-`new_key` jika sudah ada.
- **Menghapus:** `dict.pop(key)` untuk menghapus item dengan kunci tertentu (mengembalikan nilai terkait), atau `del dict[key]` untuk menghapus tanpa mengembalikan nilai. Ada juga `dict.clear()` untuk mengosongkan seluruh dictionary.
- **Melihat keys/values:** `dict.keys()` mendapatkan pandangan semua kunci, `dict.values()` pandangan semua nilai, `dict.items()` pandangan semua pasangan. Ini berguna, misalnya, dalam *loop* `for` untuk mengiterasi kunci dan/atau nilai.
- **Cek keberadaan kunci:** Menggunakan operator `in`, misal: `'brand' in my_dict` akan menghasilkan `True` jika `'brand'` adalah salah satu key di `my_dict`.
- **Metode `.update(other_dict)`** dapat digunakan untuk menggabungkan dua dictionary atau memperbarui dict dengan pasangan dari dict lain.

Sebagai *best practice*, gunakan method `.get()` jika Anda tidak yakin apakah kunci ada atau tidak (untuk menghindari error). Contohnya `my_dict.get("harga", 0)` akan mengembalikan `0` (nilai default) jika kunci `"harga"` tidak ditemukan, daripada error.

## Set

### Definisi Set dan Karakteristik Utama

**Set** adalah koleksi unik yang **tidak terurut (unordered)** dan **tidak mengizinkan elemen duplikat**. Set ditulis dengan tanda kurung kurawal `{...}` mirip dengan dict, namun hanya berisi nilai (tanpa pasangan key:value). Contoh set: `{"apple", "banana", "cherry"}`. Berlawanan dengan list/tuple, set **tidak menjamin urutan**; Anda tidak dapat mengandalkan urutan elemen dalam set. 

Set juga **tidak diindeks** – artinya Anda tidak bisa mengambil elemen set langsung dengan indeks posisi, karena konsep urutan tidak berlaku di set. Namun, set bersifat **iterable** (bisa di-*loop*), hanya saja urutannya arbitrary (acak).

Meskipun W3Schools menyebut set "unchangeable" dalam konteks isi elemen, maksudnya adalah **nilai elemen set harus immutable** (karena set menggunakan hashing, sehingga elemen yang dapat berubah akan mengacaukan himpunan). Namun **koleksi set itu sendiri mutable** – kita bisa menambah atau menghapus *elemen set* kapan saja.

Ringkasan karakteristik set:
- **Unordered:** Tidak ada urutan tetap. Setiap kali Anda mengakses atau mencetak set, urutan bisa berbeda.
- **Unique:** Tidak ada elemen yang duplikat. Jika ada nilai yang sama ditambahkan, hanya satu yang disimpan.
- **Mutable (sebagai koleksi):** Dapat ditambah atau dikurangi elemennya, tetapi elemen individual yang bisa dimasukkan harus tipe immutable (contoh: angka, string, tuple; list tidak bisa dimasukkan ke dalam set).

> **Menurut W3Schools:** *“Set items are unordered, unchangeable, and do not allow duplicate values.”*. Maksudnya, set tidak memiliki urutan indeks, elemen set (sekali dimasukkan) tidak dapat diubah nilainya (**catatan:** kita hanya bisa menambah/hapus elemen, tidak mengedit elemen tertentu), dan set menolak nilai duplikat.

Set sering digunakan ketika kita membutuhkan **kumpulan unik** dari item, atau ingin melakukan operasi himpunan seperti *union* (gabungan), *intersection* (irisan), *difference* (selisih), dan *membership test* (uji keanggotaan) dengan efisien. Operasi mengecek apakah sebuah nilai ada dalam set (`x in my_set`) umumnya sangat cepat (rata-rata *O(1)* seperti dict).

> **Dari Real Python:** *“A set is an unordered collection of objects that doesn’t allow duplicate elements. Typically, sets are used to quickly test a value for membership in the set, to insert or delete new values, and to compute the union or intersection of two sets.”*

### Contoh Penggunaan Set

Berikut contoh kode untuk set yang menunjukkan sifat unik dan operasi-operasi dasar: penambahan elemen (`add`), penghapusan elemen (`remove`), serta operasi himpunan `union` dan `intersection`:

```python
# Membuat set dengan beberapa elemen (termasuk duplikat)
fruits_set = {"apple", "banana", "cherry", "apple"}
print("Set:", fruits_set)

# Menambah elemen baru ke set
fruits_set.add("durian")
print("Set setelah add 'durian':", fruits_set)

# Menghapus elemen dari set
fruits_set.remove("banana")
print("Set setelah remove 'banana':", fruits_set)

# Operasi himpunan dengan set lain
other_set = {"cherry", "mango", "orange"}
print("Union:", fruits_set.union(other_set))
print("Intersection:", fruits_set.intersection(other_set))
```

**Penjelasan kode:**

1. `fruits_set = {"apple", "banana", "cherry", "apple"}` – Membuat sebuah set `fruits_set`. Di dalam kurawal, `"apple"` dituliskan dua kali. **Hasilnya**, set `fruits_set` **hanya akan berisi satu `"apple"`** karena duplikat otomatis diabaikan. Saat dicetak, urutan elemen mungkin berbeda dari urutan penulisan. 
2. `print("Set:", fruits_set)` – Mencetak set. Contoh output bisa `{ 'apple', 'banana', 'cherry' }` (tanpa duplikat `"apple"` kedua). Urutan bisa tampil acak; yang penting ketiga nilai unik ada.
3. `fruits_set.add("durian")` – Menambahkan string `"durian"` ke dalam set. Metode `.add(x)` menambahkan elemen ke set. Jika elemen sudah ada, set tidak berubah (tapi dalam kasus ini "durian" belum ada).
4. `print("Set setelah add 'durian':", fruits_set)` – Mencetak set setelah penambahan. Kini `fruits_set` berisi `'durian'` selain elemen sebelumnya. Urutan tetap tidak terjamin.
5. `fruits_set.remove("banana")` – Menghapus elemen `"banana"` dari set. Metode `.remove(x)` akan menghapus `x` dari set **jika ada**. (Jika `x` tidak ditemukan, ia akan error. Ada alternatif aman yaitu `.discard(x)` yang tidak error meski elemen tak ada.)
6. `print("Set setelah remove 'banana':", fruits_set)` – Mencetak set setelah penghapusan `"banana"`. Set kini tidak lagi mengandung nilai tersebut.
7. `other_set = {"cherry", "mango", "orange"}` – Membuat set lain `other_set` untuk demonstrasi operasi himpunan.
8. `print("Union:", fruits_set.union(other_set))` – Operasi *union* (gabungan) antara `fruits_set` dan `other_set` menggunakan `.union()`. Hasilnya adalah set baru yang berisi **semua elemen** dari kedua set (gabungan). Tidak ada duplikat dalam gabungan – jika ada elemen yang sama di kedua set (misal "cherry"), tetap muncul satu kali.
9. `print("Intersection:", fruits_set.intersection(other_set))` – Operasi *intersection* (irisan) menggunakan `.intersection()`. Hasilnya adalah set baru yang berisi **elemen-elemen yang ada di **kedua** set**. Dalam contoh, elemen yang sama-sama ada di `fruits_set` dan `other_set` adalah `"cherry"` saja.

**Output yang diharapkan:**

```plaintext
Set: {'apple', 'banana', 'cherry'}
Set setelah add 'durian': {'apple', 'banana', 'cherry', 'durian'}
Set setelah remove 'banana': {'apple', 'cherry', 'durian'}
Union: {'apple', 'mango', 'cherry', 'orange', 'durian'}
Intersection: {'cherry'}
```

Catatan: Urutan tampilan elemen di output bisa berbeda-beda (misalnya, `{ 'banana', 'apple', 'cherry' }` juga valid untuk mencetak `fruits_set` pertama kali). Hal ini karena set tidak terurut. Yang penting adalah **isi** kumpulan itu benar. Sebagai contoh, output *Union* mengandung 5 elemen unik gabungan, dan *Intersection* hanya mengandung `"cherry"`.

Dari output:
- Awalnya, `fruits_set` mencetak tanpa `"apple"` duplikat.
- Setelah `add("durian")`, `"durian"` muncul.
- Setelah `remove("banana")`, `"banana"` hilang.
- *Union* dari `{apple, cherry, durian}` dengan `{cherry, mango, orange}` menghasilkan `{apple, cherry, durian, mango, orange}` (semua elemen unik dari kedua set).
- *Intersection*-nya menghasilkan `{cherry}` karena hanya "cherry" yang ada di kedua set.

### Operasi dan Metode Umum pada Set

Beberapa operasi/metode penting pada set yang perlu diketahui:

- **Menambah elemen:** `.add(x)` untuk menambah satu elemen ke set. Untuk menambah multiple elemen, bisa gunakan `.update([...])` dengan iterable (misal list atau set lain).
- **Menghapus elemen:** `.remove(x)` untuk menghapus elemen *x* (akan error jika x tidak ada). `.discard(x)` melakukan hal yang sama tapi tidak error jika x tidak ada. Juga terdapat `.pop()` yang menghapus *elemen sembarang* dari set dan mengembalikannya (biasanya elemen terakhir internal, tapi karena set unordered, dianggap sembarang).
- **Operasi himpunan:** `.union(other)` atau operator `|` menghasilkan gabungan dua set. `.intersection(other)` atau operator `&` menghasilkan irisan. `.difference(other)` (`-`) menghasilkan selisih (elemen yang ada di set pertama tapi tidak di kedua). `.symmetric_difference(other)` (`^`) menghasilkan elemen yang ada di salah satu set saja tapi tidak keduanya.
- **Cek keanggotaan:** Operator `in` dan `not in` dapat digunakan untuk mengecek apakah suatu elemen ada di dalam set. Contoh: `if "apple" in fruits_set: ...`.
- **Ukuran set:** menggunakan fungsi `len(my_set)` untuk mendapat jumlah elemen unik dalam set.

Karena set tidak terurut, **tidak ada** indeks atau metode seperti `.sort()`. Jika perlu mengurutkan elemen set, Anda bisa mengubahnya sementara menjadi list terurut: `sorted_list = sorted(my_set)` – ini akan menghasilkan list baru yang terurut dari elemen-elemen set.

## Kesimpulan

Untuk merangkum, Python 3.12 menyediakan empat struktur data kolektif utama dengan kegunaan yang berbeda-beda:

- **List** – gunakan list ketika Anda butuh koleksi berurut yang isinya dapat berubah. Misalnya, list cocok untuk daftar item yang mungkin akan ditambah atau dihapus (seperti daftar tugas, keranjang belanja, dll). List ditandai dengan `[ ]` dan mendukung banyak operasi pengurutan dan penambahan.
- **Tuple** – gunakan tuple untuk koleksi berurut yang **tidak berubah**. Ideal untuk data yang bersifat konstan atau satu kesatuan logis yang tidak ingin diubah, seperti koordinat, kombinasi nilai, atau konfigurasi tetap. Tuple ditulis dengan `( )`.
- **Dictionary** – gunakan dict untuk memetakan antara **kunci unik** dan **nilai**. Ini sangat berguna untuk pencarian cepat berdasarkan kunci, seperti menyimpan data dengan identifier (contoh: kamus menerjemahkan kata ke artinya, atau mapping username ke profil). Dictionary ditulis dengan `{key: value}`.
- **Set** – gunakan set ketika Anda butuh koleksi **unik** tanpa duplikat, atau perlu melakukan operasi himpunan (gabungan, irisan, dll). Contohnya, himpunan tags, himpunan nomor unik, dsb. Set ditulis dengan `{ }` (hanya nilai).

Memahami karakteristik tiap struktur data ini akan membantu Anda memilih struktur yang tepat untuk permasalahan yang tepat. Sebagai pemula, Anda disarankan bereksperimen dengan masing-masing tipe, menggunakan metode-metode bawaan, dan merujuk dokumentasi resmi Python atau tutorial seperti W3Schools, Programiz, dan Real Python untuk pendalaman lebih lanjut. Selamat belajar dan bereksperimen dengan struktur data kolektif di Python!# Struktur Data Kolektif di Python 3.12

## Pendahuluan

Python menyediakan **4 tipe data kolektif (collection)** bawaan untuk menyimpan sekumpulan item: **list**, **tuple**, **set**, dan **dictionary**. Masing-masing tipe memiliki karakteristik dan kegunaannya sendiri. Secara umum: 

- **List** – urut (ordered), dapat diubah isinya (*mutable*), dan dapat berisi duplikat.
- **Tuple** – urut (ordered), **tidak dapat diubah** setelah dibuat (*immutable*), dan dapat berisi duplikat.
- **Set** – **tidak urut** (unordered) dan tidak terindeks, *mutable* (dapat diubah dengan menambah/menghapus elemen), **tidak** mengizinkan duplikat.
- **Dictionary (dict)** – kumpulan *key-value* (kunci-nilai) yang urut (insertion ordered), *mutable*, dan **tidak** mengizinkan kunci duplikat (setiap kunci unik mengacu ke sebuah nilai).

> **Catatan:** Menurut dokumentasi Python, *“numbers, strings and tuples are immutable, while dictionaries and lists are mutable.”* Artinya, **list dan dict bisa diubah-ubah isinya** setelah pembuatan, sedangkan **tuple tidak bisa diubah**. (Tipe *set* juga mutable – kita bisa menambah atau menghapus elemen dari set.) Pemahaman tentang sifat *mutable/immutable* ini penting ketika memilih tipe data yang tepat.

Berikut kita bahas masing-masing tipe data kolektif tersebut secara terperinci, dengan contoh kode Python 3.12 beserta penjelasan baris-per-baris dan output yang diharapkan.

## List

### Definisi List dan Karakteristik Utama

**List** adalah struktur data Python yang digunakan untuk menyimpan **sekumpulan item** dalam satu variabel. List ditulis dengan tanda kurung siku `[...]`. Item-item di dalam list **terurut** sesuai urutan penambahannya dan memiliki indeks (posisi) mulai dari 0. List bersifat **mutable** (dapat diubah setelah dibuat), sehingga kita bisa menambah, mengubah, atau menghapus elemen. List juga **mengizinkan duplikat** – artinya nilai yang sama dapat muncul lebih dari sekali di dalam list.

> **Contoh sifat list menurut W3Schools:** *“List items are ordered, changeable, and allow duplicate values.”*. Dengan kata lain, urutan elemen list tetap terjaga, isinya bisa dimodifikasi, dan nilai yang sama boleh berulang.

List cocok digunakan ketika kita membutuhkan **koleksi berurutan** yang elemennya mungkin akan diubah selama program berjalan – misalnya daftar nama pengguna, himpunan angka, dll. 

### Contoh Penggunaan List

Berikut adalah contoh kode yang mendefinisikan sebuah list dan melakukan berbagai operasi dasar pada list: menambah elemen (`append`), menyisipkan elemen pada posisi tertentu (`insert`), menghapus elemen (`remove`), dan mengurutkan elemen (`sort`). Setiap langkah akan dijelaskan:

```python
# Membuat list awal dengan beberapa elemen
fruits = ["apple", "banana", "cherry"]
print("List awal:", fruits)

# Menambahkan item di akhir list
fruits.append("durian")
print("Setelah append:", fruits)

# Menyisipkan item pada indeks ke-1
fruits.insert(1, "blueberry")
print("Setelah insert di index 1:", fruits)

# Menghapus item bernilai "banana" dari list
fruits.remove("banana")
print("Setelah remove 'banana':", fruits)

# Mengurutkan list (secara alfabetis)
fruits.sort()
print("Setelah sort:", fruits)
```

**Penjelasan kode:**

1. `fruits = ["apple", "banana", "cherry"]` – Membuat list bernama `fruits` berisi tiga string. List ditulis dengan `[ ]` dan elemen-elemen dipisahkan koma.
2. `print("List awal:", fruits)` – Mencetak list `fruits` awal. Output menunjukkan seluruh isi list.
3. `fruits.append("durian")` – Menambahkan string `"durian"` ke **akhir** list `fruits` menggunakan metode `.append()`. Metode `append()` akan menambah satu item ke ujung list.
4. `print("Setelah append:", fruits)` – Mencetak isi list `fruits` setelah penambahan. Kita akan melihat `"durian"` muncul di posisi terakhir.
5. `fruits.insert(1, "blueberry")` – Menyisipkan string `"blueberry"` ke dalam list pada **indeks 1** (posisi kedua). Metode `insert(indeks, item)` menyisipkan `item` pada indeks yang ditentukan, dan menggeser elemen setelahnya ke kanan.
6. `print("Setelah insert di index 1:", fruits)` – Mencetak isi list setelah operasi insert. `"blueberry"` sekarang berada di indeks 1, sementara elemen lainnya bergeser.
7. `fruits.remove("banana")` – Menghapus *item* bernilai `"banana"` dari list. Metode `remove(x)` akan menghapus kemunculan pertama dari nilai `x` dalam list. Setelah operasi ini, `"banana"` dihapus.
8. `print("Setelah remove 'banana':", fruits)` – Mencetak isi list setelah menghapus `"banana"`. List kini tidak mengandung nilai tersebut.
9. `fruits.sort()` – Mengurutkan elemen-elemen list *in-place* (langsung mengubah urutan dalam list tersebut). Metode `sort()` secara default mengurutkan list secara **ascending** (menaik) – untuk tipe string, urutan alfabetis A-Z.
10. `print("Setelah sort:", fruits)` – Mencetak isi list setelah pengurutan. Sekarang elemen-elemen `fruits` terurut secara alfabetis.

**Output yang diharapkan:**

```plaintext
List awal: ['apple', 'banana', 'cherry']
Setelah append: ['apple', 'banana', 'cherry', 'durian']
Setelah insert di index 1: ['apple', 'blueberry', 'banana', 'cherry', 'durian']
Setelah remove 'banana': ['apple', 'blueberry', 'cherry', 'durian']
Setelah sort: ['apple', 'blueberry', 'cherry', 'durian']
```

Terlihat bahwa operasi `append` menambah elemen di akhir list, `insert` menyisipkan elemen di posisi tertentu, `remove` menghapus elemen pertama yang nilainya sesuai, dan `sort` mengurutkan list. Karena list bersifat mutable, perubahan-perubahan ini langsung terjadi pada list yang sama.

### Metode Built-in Umum pada List

Python menyediakan banyak metode built-in untuk memanipulasi list. Beberapa metode yang paling umum meliputi:

- **`.append(x)`** – Menambah item `x` ke akhir list.
- **`.insert(i, x)`** – Menyisipkan item `x` pada indeks ke-`i`, menggeser item lama ke kanan.
- **`.remove(x)`** – Menghapus **item pertama** yang bernilai `x` dari list.
- **`.sort()`** – Mengurutkan list secara ascending (menaik) secara default. (Untuk mengurutkan descending, bisa memberikan parameter `reverse=True` atau menggunakan `list.reverse()` setelah sort).
- **`.extend(iterable)`** – Menambahkan semua elemen dari `iterable` (misal list lain) ke akhir list (mirip menggabungkan list).
- **`.pop(i)`** – Menghapus item pada indeks ke-`i` (atau terakhir jika indeks tidak disebutkan) dan mengembalikan item tersebut.
- **`.clear()`** – Mengosongkan seluruh item dalam list (menjadi list kosong).

Anda dapat menemukan daftar lengkap metode list di dokumentasi Python atau sumber seperti W3Schools. Dengan memahami metode-metode ini, manipulasi data dalam list menjadi lebih mudah. Misalnya, `append()` sangat berguna untuk menambah data ke kumpulan, `remove()` untuk menghapus data tertentu, dan `sort()` untuk pengurutan ketika diperlukan.

## Tuple

### Definisi Tuple dan Karakteristik Utama

**Tuple** adalah tipe koleksi yang mirip dengan list (menyimpan sekumpulan item berurutan), namun **bersifat immutable** – sekali tuple dibuat, isinya **tidak dapat diubah** (tidak bisa menambah, menghapus, atau mengubah elemen). Tuple ditulis dengan tanda kurung biasa `(...)`. Seperti list, tuple **terurut** (ordered) dan diindeks (dapat diakses elemen berdasarkan indeks). Tuple juga mengizinkan duplikasi nilai. 

> **Menurut W3Schools:** *“Tuple items are ordered, unchangeable, and allow duplicate values.”*. Jadi, urutan elemen tuple akan tetap, tuple tidak bisa diubah (immutable), tapi nilai yang sama dapat muncul berulang kali.

Karena sifatnya yang immutable, tuple digunakan ketika kita ingin data yang **konstan atau tetap**. Misalnya, tuple cocok untuk menyimpan koordinat (x, y, z), daftar bulan dalam setahun, atau nilai-nilai yang tidak ingin diubah secara tidak sengaja selama program berjalan. Tuple juga sering digunakan untuk **mengemas beberapa nilai** menjadi satu, misalnya nilai kembalian fungsi yang terdiri dari beberapa item.

> **Kapan memilih tuple?** *“You should prefer tuples when you have a fixed collection of items that shouldn’t change, such as coordinates or RGB color values, and when you want to ensure data integrity by preventing modifications.”*. Dengan kata lain, jika kumpulan nilai bersifat tetap dan penting untuk menjaga integritasnya, tuple adalah pilihan yang tepat.

Satu hal penting: untuk membuat tuple dengan **satu elemen saja**, kita tetap harus menuliskan sebuah koma setelah elemen tersebut. Contoh: `singleton = ("apple",)` – tanpa koma, Python akan menganggap `("apple")` sebagai *string* biasa, bukan tuple.

### Contoh Penggunaan Tuple

Berikut contoh kode mendefinisikan tuple dan beberapa operasi akses yang dapat dilakukan (walau tuple tidak bisa diubah, kita bisa membaca isinya, mencari nilai, dll):

```python
# Membuat sebuah tuple
my_tuple = ("apple", "banana", "cherry", "apple")
print("Tuple:", my_tuple)

# Mengakses elemen berdasarkan indeks
print("Elemen pertama:", my_tuple[0])

# Menghitung jumlah kemunculan nilai dalam tuple
print("Jumlah 'apple' dalam tuple:", my_tuple.count("apple"))

# Mencari indeks suatu nilai dalam tuple
print("Index 'banana' dalam tuple:", my_tuple.index("banana"))

# my_tuple[1] = "blueberry"  # contoh: ini akan error karena tuple tidak bisa diubah
```

**Penjelasan kode:**

1. `my_tuple = ("apple", "banana", "cherry", "apple")` – Membuat tuple bernama `my_tuple` dengan empat elemen. Perhatikan bahwa `"apple"` muncul dua kali (duplikat diperbolehkan). Tuple ditulis dengan tanda kurung `( )`. 
2. `print("Tuple:", my_tuple)` – Mencetak keseluruhan tuple. Output menunjukkan tuple dengan sintaks `(…)`.
3. `print("Elemen pertama:", my_tuple[0])` – Mengakses elemen pertama tuple (indeks 0) dan mencetaknya. Ini menunjukkan bahwa kita bisa *read-only* mengambil nilai berdasarkan indeks, sama seperti list.
4. `print("Jumlah 'apple' dalam tuple:", my_tuple.count("apple"))` – Menggunakan metode `.count(x)` untuk menghitung berapa kali nilai `"apple"` muncul dalam `my_tuple`. Metode `.count()` dan `.index()` adalah dua metode built-in pada tuple (kedua metode ini **tidak mengubah tuple**, hanya mengembalikan informasi).
5. `print("Index 'banana' dalam tuple:", my_tuple.index("banana"))` – Menggunakan metode `.index(x)` untuk mendapatkan indeks kemunculan pertama nilai `"banana"` dalam tuple.
6. `# my_tuple[1] = "blueberry"` – Baris ini dikomentari (tidak dieksekusi). Ini contoh percobaan mengubah nilai tuple pada indeks 1. Jika dijalankan, baris ini akan menghasilkan **TypeError** karena tuple bersifat immutable (tidak mendukung item assignment). Kita sengaja tidak mengeksekusinya untuk menghindari error dalam output, namun penting untuk dicatat bahwa operasi ini ilegal pada tuple.

**Output yang diharapkan:**

```plaintext
Tuple: ('apple', 'banana', 'cherry', 'apple')
Elemen pertama: apple
Jumlah 'apple' dalam tuple: 2
Index 'banana' dalam tuple: 1
```

Output menunjukkan isi tuple dan hasil operasi akses. Terlihat bahwa tuple `my_tuple` mengandung dua `"apple"`, sehingga `count("apple")` menghasilkan `2`. Indeks `"banana"` adalah `1` sesuai urutan di tuple. Tidak ada output untuk percobaan modifikasi karena baris tersebut tidak dijalankan – namun jika dicoba, Python akan menampilkan pesan error `'tuple' object does not support item assignment` yang menegaskan bahwa tuple tidak bisa diubah setelah diciptakan.

### Mengakses dan Mengolah Tuple (Meski Immutable)

Walaupun tuple tidak dapat diubah isinya, kita masih bisa **mengakses** elemen-elemennya menggunakan indeks atau melakukan *unpacking* (memecah tuple menjadi beberapa variabel). Contoh unpacking:

```python
coordinates = (10, 20, 30)
x, y, z = coordinates  # unpack tuple into variables
print(x, y, z)  # Output: 10 20 30
```

Jika perlu memodifikasi data yang tersimpan dalam tuple, solusi umumnya adalah **mengkonversi tuple menjadi list**, melakukan perubahan, lalu mengkonversi kembali ke tuple. Contoh pendekatan:

```python
# Misalkan ingin mengubah my_tuple di atas:
temp_list = list(my_tuple)         # ubah tuple menjadi list
temp_list[1] = "blueberry"         # modify the list
my_tuple = tuple(temp_list)        # ubah kembali menjadi tuple
print("Tuple baru:", my_tuple)     # tuple baru dengan perubahan
```

Namun perlu diingat, tuple baru yang dihasilkan berbeda objek dengan tuple awal. Jika tujuan Anda memang sering mengubah data, lebih baik sejak awal gunakan list daripada tuple.

Karena sifat immutability-nya, tuple memiliki **keterbatasan metode**. Selain `.count()` dan `.index()` yang sudah disebut, tidak ada metode seperti `append` atau `remove` pada tuple (karena tidak boleh diubah). Keuntungan immutability adalah keamanan dan integritas data – nilai-nilai di dalam tuple terjamin tidak akan berubah secara tidak sengaja selama program berjalan. Selain itu, tuple dapat digunakan sebagai **kunci dictionary** atau elemen set (sesuatu yang tidak bisa dilakukan list) karena sifatnya yang hashable (immutable).

## Dictionary (Kamus)

### Definisi Dictionary dan Karakteristik Utama

**Dictionary** (atau sering disingkat *dict*) adalah struktur data yang menyimpan pasangan **kunci: nilai** (*key:value pairs*). Setiap item di dalam dict terdiri dari **kunci (key)** dan **nilai (value)**. Dictionary ditulis dengan tanda kurung kurawal `{...}`, dengan format `key: value` untuk setiap pasangan. Contoh: `{"nama": "Ali", "umur": 25}`.

Ciri khas dictionary:
- Setiap **kunci** bersifat **unik** (tidak boleh ada duplikat key). Jika kita menggunakan key yang sama dua kali, nilai yang terakhir akan mengoverride yang sebelumnya.
- Dictionary bersifat **mutable** – kita bisa menambah, mengubah, atau menghapus pasangan kunci-nilai setelah dict dibuat.
- Sejak Python 3.7+, dictionary bersifat **ordered**, artinya urutan penambahan elemen dipertahankan. (Di Python versi lebih lama, dict dianggap tidak terurut. Tetapi dalam Python 3.12, Anda dapat mengasumsikan urutan iterasi dict sesuai urutan memasukkan item.)
- **Tidak mengizinkan duplikat kunci** – meskipun nilai boleh saja duplikat, kunci harus berbeda satu sama lain.

> **Menurut W3Schools:** *“A dictionary is a collection which is ordered*, changeable and do not allow duplicates.”*. Artinya, dict memiliki urutan (pada versi Python terbaru), bisa diubah, dan tidak boleh ada kunci yang sama.

Dictionary sangat berguna untuk melakukan **lookup/pencarian** data secara cepat berdasarkan kunci. Anda bisa membayangkan dictionary seperti **kamus** atau **buku telepon**: kunci adalah kata (atau nama), dan nilai adalah definisi (atau nomor telepon). Dengan mengetahui kunci, kita bisa dengan efisien mendapatkan nilainya tanpa harus menelusuri seluruh koleksi. Operasi pencarian, penambahan, dan penghapusan item pada dict umumnya berkompleksitas *O(1)* rata-rata, berkat implementasi *hash table* di balik layar.

> **Catatan dari Real Python:** *“In Python, dictionaries (or dicts for short) are a central data structure. Dicts store an arbitrary number of objects, each identified by a unique dictionary key. They allow for the efficient lookup, insertion, and deletion of any object associated with a given key.”*. 

Kunci pada dictionary biasanya tipe **string** atau **angka**, tetapi bisa tipe apapun yang bersifat immutable (seperti tuple). Nilainya bisa tipe data apapun (bebas, bahkan bisa list atau dict lain). 

### Contoh Penggunaan Dictionary

Berikut contoh kode untuk dictionary yang memuat beberapa informasi, dan demontrasi operasi umum: mengakses nilai, menambah & mengubah item, menghapus item, serta mendapatkan daftar kunci dan nilai:

```python
# Membuat dictionary dengan beberapa pasangan kunci:nilai
my_dict = {"brand": "Ford", "model": "Mustang", "year": 1964}
print("Dictionary:", my_dict)

# Mengakses nilai berdasarkan kunci
print("Akses nilai 'brand':", my_dict["brand"])
print("Akses nilai 'model' dengan get():", my_dict.get("model"))

# Mengubah nilai pada kunci yang sudah ada
my_dict["year"] = 2020
print("Setelah ubah 'year':", my_dict)

# Menambah pasangan kunci:nilai baru
my_dict["color"] = "red"
print("Setelah menambah 'color':", my_dict)

# Menghapus item berdasarkan kunci
my_dict.pop("model")
print("Setelah pop 'model':", my_dict)

# Melihat semua kunci, nilai, dan pasangan
print("Keys:", my_dict.keys())
print("Values:", my_dict.values())
print("Items:", my_dict.items())
```

**Penjelasan kode:**

1. `my_dict = {"brand": "Ford", "model": "Mustang", "year": 1964}` – Membuat dictionary `my_dict` dengan tiga pasangan kunci:nilai. Di sini `'brand'`, `'model'`, `'year'` adalah keys (tipe string), dan masing-masing memiliki nilai `'Ford'`, `'Mustang'`, `1964`. 
2. `print("Dictionary:", my_dict)` – Mencetak dictionary lengkap. Output akan menampilkan semua pasangan dalam sintaks `{...}`. Perhatikan urutan output sesuai urutan penambahan.
3. `print("Akses nilai 'brand':", my_dict["brand"])` – Mengakses nilai dengan kunci `'brand'` menggunakan notasi indeks `dict[key]`. Ini akan mengembalikan nilai `"Ford"`.
4. `print("Akses nilai 'model' dengan get():", my_dict.get("model"))` – Mengakses nilai dengan kunci `'model'` menggunakan metode `.get(key)`. Hasilnya sama dengan menggunakan indeks biasa, yakni `"Mustang"`. Keuntungan `.get()` adalah jika kunci tidak ada, ia *tidak* menyebabkan error `KeyError` tapi mengembalikan `None` atau nilai default yang kita tentukan.
5. `my_dict["year"] = 2020` – Mengubah nilai untuk kunci `'year'` menjadi `2020`. Karena key `'year'` sudah ada, assignment ini akan **mengganti** nilai lama `1964` dengan `2020`.
6. `print("Setelah ubah 'year':", my_dict)` – Mencetak dictionary setelah perubahan. Terlihat nilai `'year'` kini 2020.
7. `my_dict["color"] = "red"` – Menambah item baru ke dictionary dengan kunci `'color'` dan nilai `"red"`. Key `'color'` sebelumnya belum ada, jadi ini menambahkan pasangan baru ke dict.
8. `print("Setelah menambah 'color':", my_dict)` – Mencetak dictionary setelah penambahan item baru. Kini terdapat empat pasangan kunci:nilai di `my_dict` (brand, model, year, color).
9. `my_dict.pop("model")` – Menghapus item dengan kunci `'model'`. Metode `.pop(key)` akan menghapus item ber-key tersebut dan mengembalikan nilainya (dalam kasus ini akan mengembalikan `"Mustang"`, meskipun kita tidak menyimpannya). Setelah operasi ini, key `'model'` beserta nilainya tidak ada lagi di dictionary.
10. `print("Setelah pop 'model':", my_dict)` – Mencetak dictionary setelah penghapusan. Sekarang `my_dict` hanya berisi kunci `'brand'`, `'year'`, dan `'color'`.
11. `print("Keys:", my_dict.keys())` – Mendapatkan *view* keys dari dictionary menggunakan `.keys()`. Outputnya adalah objek pandangan (*dict_keys*) berisi daftar semua kunci saat ini.
12. `print("Values:", my_dict.values())` – Mendapatkan view untuk semua nilai dalam dictionary dengan `.values()`. Outputnya berupa objek *dict_values*.
13. `print("Items:", my_dict.items())` – Mendapatkan view pasangan *key-value* dengan `.items()`. Hasilnya berupa objek *dict_items* yang berisi tuple-tuple `(key, value)` untuk setiap item.

**Output yang diharapkan:**

```plaintext
Dictionary: {'brand': 'Ford', 'model': 'Mustang', 'year': 1964}
Akses nilai 'brand': Ford
Akses nilai 'model' dengan get(): Mustang
Setelah ubah 'year': {'brand': 'Ford', 'model': 'Mustang', 'year': 2020}
Setelah menambah 'color': {'brand': 'Ford', 'model': 'Mustang', 'year': 2020, 'color': 'red'}
Setelah pop 'model': {'brand': 'Ford', 'year': 2020, 'color': 'red'}
Keys: dict_keys(['brand', 'year', 'color'])
Values: dict_values(['Ford', 2020, 'red'])
Items: dict_items([('brand', 'Ford'), ('year', 2020), ('color', 'red')])
```

Mari kita perhatikan output di atas:

- **Akses nilai:** `'brand'` memberikan `"Ford"`, `'model'` memberikan `"Mustang"`. 
- **Setelah ubah `'year'`:** nilai tahun berubah menjadi 2020.
- **Setelah tambah `'color'`:** pasangan baru `'color': 'red'` muncul.
- **Setelah pop `'model'`:** pasangan dengan key `'model'` hilang dari dict.
- **Keys/Values/Items:** Hasil `my_dict.keys()` adalah `dict_keys(['brand', 'year', 'color'])`. Objek `dict_keys` ini bisa diperlakukan seperti koleksi (bisa di-*iterate* layaknya list). Jika ingin daftar biasa, kita bisa lakukan `list(my_dict.keys())` yang akan menghasilkan `['brand', 'year', 'color']`. Hal yang sama berlaku untuk `values()` dan `items()`. Objek `dict_items([...])` menampilkan setiap pasang kunci-nilai dalam bentuk tuple.

### Operasi dan Metode Umum pada Dictionary

Operasi umum yang sering digunakan pada dict antara lain:

- **Mengakses nilai:** `dict[key]` atau `dict.get(key)` untuk mendapatkan nilai berdasarkan kunci.
- **Menambahkan / Memperbarui:** `dict[new_key] = value` untuk menambah item baru, atau mengubah nilai item ber-`new_key` jika sudah ada.
- **Menghapus:** `dict.pop(key)` untuk menghapus item dengan kunci tertentu (mengembalikan nilai terkait), atau `del dict[key]` untuk menghapus tanpa mengembalikan nilai. Ada juga `dict.clear()` untuk mengosongkan seluruh dictionary.
- **Melihat keys/values:** `dict.keys()` mendapatkan pandangan semua kunci, `dict.values()` pandangan semua nilai, `dict.items()` pandangan semua pasangan. Ini berguna, misalnya, dalam *loop* `for` untuk mengiterasi kunci dan/atau nilai.
- **Cek keberadaan kunci:** Menggunakan operator `in`, misal: `'brand' in my_dict` akan menghasilkan `True` jika `'brand'` adalah salah satu key di `my_dict`.
- **Metode `.update(other_dict)`** dapat digunakan untuk menggabungkan dua dictionary atau memperbarui dict dengan pasangan dari dict lain.

Sebagai *best practice*, gunakan method `.get()` jika Anda tidak yakin apakah kunci ada atau tidak (untuk menghindari error). Contohnya `my_dict.get("harga", 0)` akan mengembalikan `0` (nilai default) jika kunci `"harga"` tidak ditemukan, daripada error.

## Set

### Definisi Set dan Karakteristik Utama

**Set** adalah koleksi unik yang **tidak terurut (unordered)** dan **tidak mengizinkan elemen duplikat**. Set ditulis dengan tanda kurung kurawal `{...}` mirip dengan dict, namun hanya berisi nilai (tanpa pasangan key:value). Contoh set: `{"apple", "banana", "cherry"}`. Berlawanan dengan list/tuple, set **tidak menjamin urutan**; Anda tidak dapat mengandalkan urutan elemen dalam set. 

Set juga **tidak diindeks** – artinya Anda tidak bisa mengambil elemen set langsung dengan indeks posisi, karena konsep urutan tidak berlaku di set. Namun, set bersifat **iterable** (bisa di-*loop*), hanya saja urutannya arbitrary (acak).

Meskipun W3Schools menyebut set "unchangeable" dalam konteks isi elemen, maksudnya adalah **nilai elemen set harus immutable** (karena set menggunakan hashing, sehingga elemen yang dapat berubah akan mengacaukan himpunan). Namun **koleksi set itu sendiri mutable** – kita bisa menambah atau menghapus *elemen set* kapan saja.

Ringkasan karakteristik set:
- **Unordered:** Tidak ada urutan tetap. Setiap kali Anda mengakses atau mencetak set, urutan bisa berbeda.
- **Unique:** Tidak ada elemen yang duplikat. Jika ada nilai yang sama ditambahkan, hanya satu yang disimpan.
- **Mutable (sebagai koleksi):** Dapat ditambah atau dikurangi elemennya, tetapi elemen individual yang bisa dimasukkan harus tipe immutable (contoh: angka, string, tuple; list tidak bisa dimasukkan ke dalam set).

> **Menurut W3Schools:** *“Set items are unordered, unchangeable, and do not allow duplicate values.”*. Maksudnya, set tidak memiliki urutan indeks, elemen set (sekali dimasukkan) tidak dapat diubah nilainya (**catatan:** kita hanya bisa menambah/hapus elemen, tidak mengedit elemen tertentu), dan set menolak nilai duplikat.

Set sering digunakan ketika kita membutuhkan **kumpulan unik** dari item, atau ingin melakukan operasi himpunan seperti *union* (gabungan), *intersection* (irisan), *difference* (selisih), dan *membership test* (uji keanggotaan) dengan efisien. Operasi mengecek apakah sebuah nilai ada dalam set (`x in my_set`) umumnya sangat cepat (rata-rata *O(1)* seperti dict).

> **Dari Real Python:** *“A set is an unordered collection of objects that doesn’t allow duplicate elements. Typically, sets are used to quickly test a value for membership in the set, to insert or delete new values, and to compute the union or intersection of two sets.”*

### Contoh Penggunaan Set

Berikut contoh kode untuk set yang menunjukkan sifat unik dan operasi-operasi dasar: penambahan elemen (`add`), penghapusan elemen (`remove`), serta operasi himpunan `union` dan `intersection`:

```python
# Membuat set dengan beberapa elemen (termasuk duplikat)
fruits_set = {"apple", "banana", "cherry", "apple"}
print("Set:", fruits_set)

# Menambah elemen baru ke set
fruits_set.add("durian")
print("Set setelah add 'durian':", fruits_set)

# Menghapus elemen dari set
fruits_set.remove("banana")
print("Set setelah remove 'banana':", fruits_set)

# Operasi himpunan dengan set lain
other_set = {"cherry", "mango", "orange"}
print("Union:", fruits_set.union(other_set))
print("Intersection:", fruits_set.intersection(other_set))
```

**Penjelasan kode:**

1. `fruits_set = {"apple", "banana", "cherry", "apple"}` – Membuat sebuah set `fruits_set`. Di dalam kurawal, `"apple"` dituliskan dua kali. **Hasilnya**, set `fruits_set` **hanya akan berisi satu `"apple"`** karena duplikat otomatis diabaikan. Saat dicetak, urutan elemen mungkin berbeda dari urutan penulisan. 
2. `print("Set:", fruits_set)` – Mencetak set. Contoh output bisa `{ 'apple', 'banana', 'cherry' }` (tanpa duplikat `"apple"` kedua). Urutan bisa tampil acak; yang penting ketiga nilai unik ada.
3. `fruits_set.add("durian")` – Menambahkan string `"durian"` ke dalam set. Metode `.add(x)` menambahkan elemen ke set. Jika elemen sudah ada, set tidak berubah (tapi dalam kasus ini "durian" belum ada).
4. `print("Set setelah add 'durian':", fruits_set)` – Mencetak set setelah penambahan. Kini `fruits_set` berisi `'durian'` selain elemen sebelumnya. Urutan tetap tidak terjamin.
5. `fruits_set.remove("banana")` – Menghapus elemen `"banana"` dari set. Metode `.remove(x)` akan menghapus `x` dari set **jika ada**. (Jika `x` tidak ditemukan, ia akan error. Ada alternatif aman yaitu `.discard(x)` yang tidak error meski elemen tak ada.)
6. `print("Set setelah remove 'banana':", fruits_set)` – Mencetak set setelah penghapusan `"banana"`. Set kini tidak lagi mengandung nilai tersebut.
7. `other_set = {"cherry", "mango", "orange"}` – Membuat set lain `other_set` untuk demonstrasi operasi himpunan.
8. `print("Union:", fruits_set.union(other_set))` – Operasi *union* (gabungan) antara `fruits_set` dan `other_set` menggunakan `.union()`. Hasilnya adalah set baru yang berisi **semua elemen** dari kedua set (gabungan). Tidak ada duplikat dalam gabungan – jika ada elemen yang sama di kedua set (misal "cherry"), tetap muncul satu kali.
9. `print("Intersection:", fruits_set.intersection(other_set))` – Operasi *intersection* (irisan) menggunakan `.intersection()`. Hasilnya adalah set baru yang berisi **elemen-elemen yang ada di **kedua** set**. Dalam contoh, elemen yang sama-sama ada di `fruits_set` dan `other_set` adalah `"cherry"` saja.

**Output yang diharapkan:**

```plaintext
Set: {'apple', 'banana', 'cherry'}
Set setelah add 'durian': {'apple', 'banana', 'cherry', 'durian'}
Set setelah remove 'banana': {'apple', 'cherry', 'durian'}
Union: {'apple', 'mango', 'cherry', 'orange', 'durian'}
Intersection: {'cherry'}
```

Catatan: Urutan tampilan elemen di output bisa berbeda-beda (misalnya, `{ 'banana', 'apple', 'cherry' }` juga valid untuk mencetak `fruits_set` pertama kali). Hal ini karena set tidak terurut. Yang penting adalah **isi** kumpulan itu benar. Sebagai contoh, output *Union* mengandung 5 elemen unik gabungan, dan *Intersection* hanya mengandung `"cherry"`.

Dari output:
- Awalnya, `fruits_set` mencetak tanpa `"apple"` duplikat.
- Setelah `add("durian")`, `"durian"` muncul.
- Setelah `remove("banana")`, `"banana"` hilang.
- *Union* dari `{apple, cherry, durian}` dengan `{cherry, mango, orange}` menghasilkan `{apple, cherry, durian, mango, orange}` (semua elemen unik dari kedua set).
- *Intersection*-nya menghasilkan `{cherry}` karena hanya "cherry" yang ada di kedua set.

### Operasi dan Metode Umum pada Set

Beberapa operasi/metode penting pada set yang perlu diketahui:

- **Menambah elemen:** `.add(x)` untuk menambah satu elemen ke set. Untuk menambah multiple elemen, bisa gunakan `.update([...])` dengan iterable (misal list atau set lain).
- **Menghapus elemen:** `.remove(x)` untuk menghapus elemen *x* (akan error jika x tidak ada). `.discard(x)` melakukan hal yang sama tapi tidak error jika x tidak ada. Juga terdapat `.pop()` yang menghapus *elemen sembarang* dari set dan mengembalikannya (biasanya elemen terakhir internal, tapi karena set unordered, dianggap sembarang).
- **Operasi himpunan:** `.union(other)` atau operator `|` menghasilkan gabungan dua set. `.intersection(other)` atau operator `&` menghasilkan irisan. `.difference(other)` (`-`) menghasilkan selisih (elemen yang ada di set pertama tapi tidak di kedua). `.symmetric_difference(other)` (`^`) menghasilkan elemen yang ada di salah satu set saja tapi tidak keduanya.
- **Cek keanggotaan:** Operator `in` dan `not in` dapat digunakan untuk mengecek apakah suatu elemen ada di dalam set. Contoh: `if "apple" in fruits_set: ...`.
- **Ukuran set:** menggunakan fungsi `len(my_set)` untuk mendapat jumlah elemen unik dalam set.

Karena set tidak terurut, **tidak ada** indeks atau metode seperti `.sort()`. Jika perlu mengurutkan elemen set, Anda bisa mengubahnya sementara menjadi list terurut: `sorted_list = sorted(my_set)` – ini akan menghasilkan list baru yang terurut dari elemen-elemen set.

## Kesimpulan

Untuk merangkum, Python 3.12 menyediakan empat struktur data kolektif utama dengan kegunaan yang berbeda-beda:

- **List** – gunakan list ketika Anda butuh koleksi berurut yang isinya dapat berubah. Misalnya, list cocok untuk daftar item yang mungkin akan ditambah atau dihapus (seperti daftar tugas, keranjang belanja, dll). List ditandai dengan `[ ]` dan mendukung banyak operasi pengurutan dan penambahan.
- **Tuple** – gunakan tuple untuk koleksi berurut yang **tidak berubah**. Ideal untuk data yang bersifat konstan atau satu kesatuan logis yang tidak ingin diubah, seperti koordinat, kombinasi nilai, atau konfigurasi tetap. Tuple ditulis dengan `( )`.
- **Dictionary** – gunakan dict untuk memetakan antara **kunci unik** dan **nilai**. Ini sangat berguna untuk pencarian cepat berdasarkan kunci, seperti menyimpan data dengan identifier (contoh: kamus menerjemahkan kata ke artinya, atau mapping username ke profil). Dictionary ditulis dengan `{key: value}`.
- **Set** – gunakan set ketika Anda butuh koleksi **unik** tanpa duplikat, atau perlu melakukan operasi himpunan (gabungan, irisan, dll). Contohnya, himpunan tags, himpunan nomor unik, dsb. Set ditulis dengan `{ }` (hanya nilai).

Memahami karakteristik tiap struktur data ini akan membantu Anda memilih struktur yang tepat untuk permasalahan yang tepat. Sebagai pemula, Anda disarankan bereksperimen dengan masing-masing tipe, menggunakan metode-metode bawaan, dan merujuk dokumentasi resmi Python atau tutorial seperti W3Schools, Programiz, dan Real Python untuk pendalaman lebih lanjut. Selamat belajar dan bereksperimen dengan struktur data kolektif di Python!