# Paradigma dan Gaya Penulisan Dart – Panduan untuk Pemula

Bahasa **Dart** merupakan bahasa pemrograman modern yang sangat mendukung **paradigma berorientasi objek berbasis kelas (class-based OOP)**, dengan fitur-fitur seperti **null safety**, **mixin**, **kelas abstrak**, dan penulisan kode yang **ringkas (terse style)** menggunakan **typedef**. Dalam panduan ini, kita akan membahas lima topik utama tersebut secara terstruktur dan terperinci. Setiap topik akan dijelaskan konsep dasarnya, sintaks dan contoh kode Dart lengkap, penjelasan kode baris-per-baris, kegunaan dalam pengembangan aplikasi, serta kesalahan umum yang sering dilakukan pemula dan cara menghindarinya. Panduan ini ditulis dengan bahasa yang ramah pemula dan gaya penjelasan yang aplikatif sehingga mudah dipahami oleh Anda yang baru mulai belajar Dart.

## 1. Class-based OOP (Pemrograman Berbasis Kelas)

**Konsep Dasar & Tujuan:**
Class-based OOP adalah paradigma di mana *class/kelas* digunakan sebagai blueprint (cetak biru) untuk membuat objek. Dart adalah bahasa pemrograman berorientasi objek dengan dukungan kelas dan pewarisan berbasis mixin. **Kelas** mendefinisikan atribut (data) dan perilaku (fungsi/method) yang dimiliki oleh objek. **Objek** adalah instance konkret yang dibuat berdasarkan kelas tersebut. Tujuan penggunaan kelas adalah untuk mengorganisasi kode agar lebih modular dan merepresentasikan konsep dunia nyata dalam bentuk kode (misal: kelas `Person` merepresentasikan orang dengan atribut nama/umur dan perilaku menyapa). Paradigma OOP mempermudah *encapsulation* (pembungkusan data dan fungsi dalam satu unit), *inheritance* (pewarisan sifat antar kelas), dan *polymorphism* (kemampuan objek berperilaku berbeda-beda). Bagi pemula, memahami kelas berarti memahami cara mendefinisikan tipe baru yang berisi variabel dan fungsi yang terkait secara logis.

**Sintaks Umum & Contoh Kode:**
Untuk mendefinisikan kelas di Dart, gunakan keyword `class` diikuti nama kelas dan blok kurung kurawal `{ }`. Di dalamnya, Anda dapat mendefinisikan **field** (variabel anggota) dan **method** (fungsi anggota). Kelas dapat memiliki **konstruktor** untuk inisialisasi objek. Berikut contoh kelas sederhana bernama `Person` dengan dua field, satu konstruktor, dan satu method, beserta contoh penggunaannya di fungsi `main()`:

```dart
class Person {
  String name;      // Field/atribut nama (tipe String)
  int age;          // Field/atribut umur (tipe int)

  // Konstruktor kelas Person
  Person(this.name, this.age);

  // Method memperkenalkan diri
  void introduce() {
    print('Halo, nama saya $name dan umur saya $age tahun.');
  }
}

void main() {
  // Membuat objek Person
  Person person1 = Person("Alice", 30);
  // Memanggil method pada objek person1
  person1.introduce();
}
```

**Penjelasan Kode:**

* **Baris 1:** `class Person { ... }` – Mendefinisikan sebuah kelas bernama `Person`. Kurung kurawal membuka blok isi kelas.
* **Baris 2-3:** `String name; int age;` – Mendeklarasikan dua **field** dalam kelas `Person`, yaitu `name` (tipe String) dan `age` (tipe int). Field ini akan dimiliki oleh setiap objek `Person`.
* **Baris 5-6:** `Person(this.name, this.age);` – Mendefinisikan **konstruktor** kelas `Person`. Konstruktor ini menggunakan *shortcut* `this.name` dan `this.age` untuk langsung menginisialisasi field `name` dan `age` dengan nilai yang diberikan saat objek dibuat. Jadi, saat membuat `Person("Alice", 30)`, nilai "Alice" akan diassign ke `this.name` dan 30 ke `this.age`.
* **Baris 9-12:** `void introduce() { ... }` – Mendefinisikan **method** bernama `introduce` dalam kelas `Person`. Method ini tidak mengembalikan nilai (`void`) dan mencetak pesan perkenalan menggunakan nilai field `name` dan `age` milik objek yang memanggilnya. Di dalam string, `$name` dan `$age` otomatis digantikan dengan nilai properti objek (ini fitur *string interpolation* di Dart).
* **Baris 14:** `void main() { ... }` – Fungsi `main()` sebagai titik awal eksekusi program Dart.
* **Baris 16:** `Person person1 = Person("Alice", 30);` – Membuat **objek** `Person` baru dengan memanggil konstruktor `Person(...)` dan menyimpannya ke variabel `person1`. Ini mengalokasikan objek dengan `name = "Alice"` dan `age = 30`.
* **Baris 18:** `person1.introduce();` – Memanggil method `introduce()` pada objek `person1`. Hal ini akan mengeksekusi kode di dalam `introduce` untuk `person1`, sehingga mencetak `Halo, nama saya Alice dan umur saya 30 tahun.` ke konsol.

**Kapan dan Bagaimana Digunakan:**
Kelas digunakan hampir di semua program Dart dan Flutter untuk mengorganisir kode berdasarkan konsep objek. Anda akan membuat kelas untuk merepresentasikan entitas dalam aplikasi. Misalnya, dalam aplikasi toko Anda bisa punya kelas `Product`, `Customer`, `Order`, dll. Kelas memungkinkan *encapsulation*: data dan fungsi yang beroperasi pada data tersebut dikelompokkan bersama, sehingga kode lebih terstruktur. Kelas juga memungkinkan *inheritance* (pewarisan), di mana suatu kelas dapat mewarisi sifat (field dan method) dari kelas lain, dan *polymorphism* di mana objek bisa diakses melalui tipe induknya namun berperilaku sesuai kelas nyatanya. Dalam Flutter (framework UI berbasis Dart), Anda akan sering membuat kelas untuk *Widget* atau *State* yang memperluas (extend) kelas base dari framework. Intinya, gunakan kelas saat Anda ingin membuat tipe data kustom dengan properti dan perilaku, terutama jika Anda butuh membuat banyak objek dengan struktur serupa.

**Kesalahan Umum Pemula & Cara Menghindarinya:**

* **Lupa Menginisialisasi Field:** Dalam Dart dengan null safety, *field* non-nullable (tanpa `?`) harus diinisialisasi. Pemula sering lupa memberi nilai awal atau menggunakan konstruktor untuk mengisi field, yang mengakibatkan error. Solusinya, inisialisasi semua field non-nullable di konstruktor atau langsung saat deklarasi.
* **Kebingungan Antara Class vs Object:** Kadang pemula mencoba mengakses anggota kelas tanpa membuat objek. Ingat, *field* dan *method* bukan *static* hanya bisa diakses melalui objek (misal, `person1.name`, bukan `Person.name`). Pastikan untuk membuat instance (objek) dengan keyword `new` (opsional di Dart) atau langsung memanggil konstruktor seperti contoh di atas.
* **Penamaan yang Tidak Konsisten:** Gunakan konvensi penamaan **CamelCase** untuk nama kelas (`MyClass`) dan **lowerCamelCase** untuk nama objek, variabel, dan method (`myObject`, `doSomething()`). Penamaan konsisten memudahkan pembacaan kode.
* **Menggunakan `new` yang Tidak Perlu:** Dart modern tidak memerlukan keyword `new` untuk membuat objek (penggunaan `Person("Alice", 30)` sudah cukup). Menulis `new Person(...)` tidak salah, tapi tidak idiomatis. Pemula sebaiknya membiasakan style tanpa `new` agar kode lebih bersih.
* **Tidak Menggunakan Konstruktor dengan Benar:** Misalnya, mencoba membuat beberapa konstruktor seperti di Java (method overload). Dart tidak mengizinkan dua konstruktor dengan nama yang sama, tapi Anda bisa membuat *named constructor* (misal `Person.fromJson(...)`). Pelajari sintaks *named constructor* jika butuh variasi cara inisialisasi objek. Selalu panggil konstruktor yang benar saat membuat objek.
* **Tidak Menggunakan `this` Saat Diperlukan:** Dalam konstruktor, pemula kadang memberi parameter nama yang sama dengan field tetapi lupa menggunakan `this`. Contoh:

  ```dart
  class Person { 
    String name;
    Person(String name) {
      name = name; // Salah: kedua 'name' di sini mengacu ke parameter, bukan field
    }
  }
  ```

  Ini tidak mengubah field kelas. Solusinya, gunakan `this.name = name` atau lebih idiomatis, gunakan langsung `Person(this.name)` seperti contoh sebelumnya untuk menghindari kebingungan.

## 2. Null Safety

**Konsep Dasar & Tujuan:**
**Null safety** adalah fitur Dart yang mencegah error akibat penggunaan nilai `null` secara tak terduga. Sebelum null safety, salah satu penyebab crash aplikasi yang umum adalah *NullReference Error* (akses ke objek `null`). Dart mengatasi ini dengan menjadikan semua variabel *non-nullable secara default*, artinya variabel tidak bisa menyimpan `null` kecuali secara eksplisit diizinkan. **Null safety mencegah error yang disebabkan oleh akses tak disengaja ke variabel yang bernilai null**. Contohnya, jika sebuah fungsi mengharapkan parameter bertipe `int` tetapi `null` diberikan, program akan error runtime. Dengan null safety, kesalahan seperti itu dideteksi sejak *compile-time* sehingga kita bisa memperbaiki kode sebelum aplikasi dijalankan. Singkatnya, null safety meningkatkan **keamanan dan keandalan kode** dengan memastikan bahwa nilai null ditangani dengan benar dan tidak menyebabkan crash di tengah jalan.

**Sintaks Umum & Contoh Kode:**
Dalam Dart versi null safety (Dart 2.12 ke atas), Anda harus secara eksplisit menandai variabel yang boleh bernilai null. Berikut sintaks dan operator penting terkait null safety:

* **Tipe Non-Nullable (default):** Tipe tanpa tanda tanya (`?`) tidak boleh bernilai `null`. Misal `int x = 5;` maka `x` tidak bisa di-assign `null`. Jika Anda mencoba `x = null;`, akan muncul error pada saat kompilasi.
* **Tipe Nullable:** Tambahkan `?` setelah nama tipe untuk mengizinkan `null`. Misal `int? y;` berarti `y` bisa bernilai `int` ataupun `null`. Variabel nullable yang belum diinisialisasi default-nya adalah `null`.
* **Null-aware operator `?.`** – digunakan untuk mengakses member secara aman. Misal `obj?.member` akan menghasilkan `null` jika `obj` adalah null, alih-alih menyebabkan error. Ini berguna saat Anda tidak yakin apakah objek null atau tidak.
* **Operator `??` (coalescing):** Mengembalikan operand di sebelah kiri jika tidak null, tetapi jika null akan mengembalikan nilai di sebelah kanan. Misal `a ?? b` akan menghasilkan `a` jika `a` tidak null, tapi jika `a` null maka hasilnya `b`. Sering digunakan untuk memberi nilai default.
* **Operator `??=`:** Menetapkan nilai di kanan ke variabel di kiri hanya jika variabel di kiri saat ini bernilai null. Misal `x ??= 10;` akan mengisi `x` dengan 10 jika `x` null.
* **Not-null assertion `!`:** Menandakan bahwa Anda *yakin* suatu ekspresi bukan null. Misal `nullableVar!` akan menganggap `nullableVar` bukan null. Jika ternyata `nullableVar` null di runtime, ini akan memicu error. Gunakan operator `!` dengan hati-hati; ini semacam "mematikan" mekanisme null safety secara lokal.

Berikut contoh kode yang mendemonstrasikan penggunaan null safety dan operator-operator di atas:

```dart
void main() {
  // Deklarasi variabel dengan null safety
  String? nullableName;            // nullable, default-nya null
  String nonNullableName = "Dart"; // non-nullable, harus diinisialisasi

  print(nullableName);        // Output: null (saat ini bernilai null)
  // print(nullableName.length);  // SALAH: nullableName bisa null, tidak boleh akses .length
  print(nullableName?.length);    // Output: null (aman, karena menggunakan '?.')

  nullableName = "Flutter";       
  print(nullableName.length);     // Output: 7 (sudah tidak null, bisa panggil .length)

  nullableName = null;
  String nameWithFallback = nullableName ?? "Guest";
  print(nameWithFallback);   // Output: Guest (karena nullableName null, pakai nilai default)

  // Contoh penggunaan operator '!' (hati-hati)
  String? maybeName = "Alice";
  print(maybeName!.toUpperCase()); // Output: ALICE (kita yakin maybeName tidak null di sini)
  maybeName = null;
  // print(maybeName!.toUpperCase()); // JANGAN: ini akan error runtime karena maybeName null
}
```

**Penjelasan Kode:**

* **Baris 2:** `String? nullableName;` – Mendeklarasikan `nullableName` bertipe `String?` (String nullable). Karena tidak diinisialisasi, secara default `nullableName` bernilai `null`. Variabel ini diizinkan bernilai null karena tipe-nya ditandai `?`.
* **Baris 3:** `String nonNullableName = "Dart";` – Mendeklarasikan `nonNullableName` bertipe `String` (tanpa `?`, artinya non-nullable) dan langsung menginisialisasinya dengan `"Dart"`. Variabel non-nullable **wajib** diinisialisasi nilai non-null sebelum digunakan, jika tidak, kode tidak akan lolos kompilasi.
* **Baris 5:** `print(nullableName);` – Mencetak nilai `nullableName`. Karena belum pernah diisi, nilainya adalah `null`, sehingga yang tercetak di konsol adalah `null`.
* **Baris 6 (komentar):** `// print(nullableName.length);` – Contoh kode yang **salah** (dikomentari agar tidak dieksekusi). Jika kita mencoba mengakses `nullableName.length` secara langsung, kompilator akan error, karena `nullableName` bisa `null` sehingga akses langsung berbahaya. Ini menunjukkan bagaimana null safety mencegah kita melakukan operasi tidak aman.
* **Baris 7:** `print(nullableName?.length);` – Menggunakan operator `?.` (null-aware access) untuk aman memanggil `length`. Karena `nullableName` saat ini `null`, ekspresi `nullableName?.length` akan menghasilkan `null` (bukannya error). Jadi baris ini mencetak `null`.
* **Baris 9:** `nullableName = "Flutter";` – Memberikan nilai `"Flutter"` ke `nullableName`. Sekarang `nullableName` tidak lagi null, melainkan `"Flutter"`.
* **Baris 10:** `print(nullableName.length);` – Sekarang aman untuk mengakses `nullableName.length` tanpa `?.` karena kita tahu `nullableName` berisi `"Flutter"` (non-null). Baris ini akan mencetak panjang string `"Flutter"`, yaitu `7`. (Catatan: Kompilator Dart juga melakukan **promosi tipe**; setelah pemeriksaan `nullableName != null`, atau setelah assignment langsung seperti ini, Dart menganggapnya non-null di bawah kap sehingga akses .length diizinkan).
* **Baris 12:** `nullableName = null;` – Mengatur kembali `nullableName` ke null.
* **Baris 13:** `String nameWithFallback = nullableName ?? "Guest";` – Menggunakan operator `??`. Ekspresi `nullableName ?? "Guest"` akan menghasilkan `"Guest"` karena `nullableName` saat ini null. Hasil tersebut disimpan dalam `nameWithFallback`. Dengan demikian, `nameWithFallback` akan bernilai `"Guest"`.
* **Baris 14:** `print(nameWithFallback);` – Mencetak nilai `nameWithFallback`, yang menghasilkan output `Guest`. Ini menunjukkan penggunaan `??` untuk memberikan **nilai *fallback* atau default** ketika variabel bernilai null.
* **Baris 17:** `String? maybeName = "Alice";` – Deklarasi `maybeName` sebagai `String?` dan langsung diisi `"Alice"`. Jadi `maybeName` berisi sebuah string non-null saat ini, namun tipe-nya tetap nullable (bisa di-null-kan lagi nanti).
* **Baris 18:** `print(maybeName!.toUpperCase());` – Contoh penggunaan operator `!` (not-null assertion). Di sini kita meyakinkan Dart bahwa `maybeName` **bukan** null, sehingga kita bisa memperlakukannya sebagai non-nullable. Akibatnya, kita dapat memanggil `toUpperCase()` yang merupakan method `String`. Karena `maybeName` memang berisi `"Alice"`, baris ini akan mencetak `ALICE`. **Peringatan:** Jika ternyata `maybeName` null, penggunaan `!` akan memicu error runtime `Null check operator used on a null value`. Gunakan `!` hanya jika Anda *100% yakin* variabel tidak null pada titik tersebut.
* **Baris 19-20 (komentar):** Mengubah `maybeName` menjadi null dan kemudian mencoba `maybeName!.toUpperCase()`. Kode ini dikomentari karena akan menyebabkan runtime error. Ini untuk menunjukkan **kesalahan umum**: jangan menggunakan `!` pada variabel yang bisa null kecuali Anda yakin variabelnya sudah dicek atau diassign nilai non-null tepat sebelum penggunaan.

**Kapan dan Bagaimana Digunakan:**
Null safety digunakan **setiap saat** dalam penulisan kode Dart modern karena ini merupakan bagian integral dari bahasa sejak versi 2.12. Sebagai pengembang, Anda harus selalu mempertimbangkan apakah suatu variabel boleh null atau tidak, dan mendeklarasikan tipenya sesuai (`T?` jika boleh null, atau `T` non-nullable jika tidak). Dalam pengembangan aplikasi Dart/Flutter, null safety membantu menghindari crash. Misalnya, saat mengelola input pengguna atau memproses data dari internet, Anda mungkin mendapatkan nilai null (contoh: response API tidak mengandung field yang diharapkan). Dengan null safety, Anda terpaksa menulis logika penanganan (misal menggunakan `??` untuk default, atau pengecekan `if != null`) sehingga aplikasi Anda lebih tangguh. Null safety juga membuat kode lebih *self-documenting*: dari tipe variabel saja sudah jelas apakah perlu cek null atau tidak. Saat menggunakan library, null safety memastikan Anda menangani nilai null sesuai kontrak yang ditetapkan oleh API library tersebut. Singkatnya, null safety membuat Anda menulis kode yang **aman dari null error** secara proaktif, alih-alih bereaksi setelah bug terjadi.

**Kesalahan Umum Pemula & Cara Menghindarinya:**

* **Menandai Semua Variabel sebagai Nullable tanpa Alasan:** Pemula kadang menambahkan `?` pada semua tipe sampai tidak ada error, tanpa memahami apakah seharusnya variabel itu boleh null. Ini membuat kode penuh dengan kemungkinan null yang tidak perlu dan berpotensi menyembunyikan bug. Solusinya, berpikirlah: Apakah variabel ini *logisnya* bisa tidak memiliki nilai? Jika *iya*, barulah buat nullable; jika *tidak*, ubah logika program alih-alih menandai nullable. Usahakan sebagian besar variabel Anda non-nullable kecuali memang ada kasus null.
* **Penggunaan `!` (Null Assertion) Sembarangan:** Operator `!` sebaiknya jarang dipakai oleh pemula. Terkadang pemula menggunakannya untuk *mengakali* error null safety tanpa memahami akar masalah. Misal, menulis `myVar!.method()` hanya karena `myVar.method()` menghasilkan error kompiler. Ini berbahaya jika tidak benar-benar dijamin non-null. Hindari `!` kecuali Anda sudah melakukan pengecekan `if (myVar != null)` tepat sebelum itu, atau inisialisasi yang memastikan non-null. Lebih baik gunakan pendekatan aman seperti null check atau `?.` dan `??`.
* **Lupa Menginisialisasi Variabel Non-nullable:** Berbeda dari bahasa tanpa null safety, di Dart Anda **wajib** menginisialisasi variabel lokal non-nullable sebelum digunakan, atau akan kena error *definite assignment*. Pemula mungkin bingung mengapa harus memberi nilai awal. Solusinya, berikan default atau segera isi variabel tersebut. Jika secara logika variabel baru diisi belakangan, pertimbangkan menjadikannya `late` (untuk variabel yang akan diinisialisasi kemudian sebelum digunakan).
* **Tidak Menangani Kembalian Nullable dari Function/Method:** Misalnya, method `String? getName()` bisa mengembalikan null tapi pemula memperlakukannya seperti non-null (langsung `getName().length`). Ini akan ditolak oleh kompiler. Pastikan selalu memperhatikan tipe return; jika `Foo?`, tangani kemungkinan null (misal: simpan ke var lalu cek, atau gunakan `?.`/`??`).
* **Mengabaikan Pesan Error Null Safety:** Saat kompiler Dart memberi peringatan atau error terkait null safety, baca dengan teliti. Biasanya dijelaskan bahwa *variable X might be null*. Pemula kadang hanya menambahkan tanda seru `!` untuk menghilangkan error tanpa memahami penyebab. Lebih baik pahami mengapa variabel bisa null di jalur kode tersebut dan perbaiki alur logika atau tambahkan pengamanan.
* **Belum Memahami `late`:** Keyword `late` digunakan untuk menandai variabel yang akan diinisialisasi belakangan (misal dalam framework seperti Flutter, beberapa variabel diinisialisasi di `initState`). Pemula kadang tidak tahu ini dan membuat variabel nullable padahal sebetulnya ingin menunda inisialisasi. Gunakan `late` untuk variabel yang dijamin akan diinisialisasi sebelum diakses, agar tetap non-nullable namun diizinkan deklarasi tanpa nilai awal. Tetapi hati-hati: jika `late` variable diakses sebelum diinisialisasi, akan terjadi runtime error. Jadi pastikan inisialisasi dilakukan.

## 3. Mixin

**Konsep Dasar & Tujuan:**
**Mixin** adalah fitur Dart yang memungkinkan *reuse* (penggunaan ulang) kode di berbagai kelas tanpa menggunakan pewarisan tunggal secara klasik. Secara sederhana, mixin adalah potongan kelas (berupa property dan method) yang dapat disisipkan ke dalam *class* lain. *Mixin* menyediakan cara untuk mendefinisikan kode yang dapat digunakan ulang di banyak hierarki kelas. Berbeda dengan pewarisan biasa di mana sebuah kelas hanya bisa punya satu superclass, dengan mixin sebuah kelas dapat **mencampurkan** (mix in) beberapa perilaku dari berbagai sumber. Tujuan utamanya adalah menghindari duplikasi kode dan memungkinkan pengelompokan fungsi yang logikanya bisa dipakai di beberapa kelas yang tidak terhubung dalam hubungan pewarisan langsung.

Dart menggunakan konsep *mixin-based inheritance*, artinya meskipun setiap kelas punya satu superclass, tubuh kelas tersebut bisa digunakan di beberapa tempat melalui mixin. Mixin dalam Dart mirip seperti **traits** di bahasa lain atau *multiple inheritance* versi aman: Anda dapat menambahkan kemampuan tambahan pada kelas tanpa harus menjadi subclass dari kelas tertentu.

**Sintaks Umum & Contoh Kode:**
Untuk mendefinisikan sebuah mixin, gunakan keyword `mixin` diikuti nama mixin dan blok `{ }`. Di dalamnya, Anda dapat menuliskan field dan method seperti pada kelas biasa. Namun, **mixin tidak boleh memiliki konstruktor** dan tidak boleh men-*extend* kelas lain (kecuali menggunakan kata kunci `on` untuk syarat tertentu, fitur lanjutan). Mixin biasanya ditulis dengan huruf kapital di awal namanya (seperti kelas).

Untuk menggunakan mixin pada sebuah kelas, gunakan keyword `with` diikuti nama mixin (atau beberapa mixin dipisah koma) setelah deklarasi `extends` (jika ada). Kelas yang menggunakan mixin akan mewarisi semua field dan method dari mixin seolah-olah ditulis di kelas tersebut. Berikut contoh sederhana:

```dart
mixin CanFly {
  void fly() {
    print("Terbang melintasi langit!");
  }
}

mixin CanSwim {
  void swim() {
    print("Berenang di dalam air!");
  }
}

// Sebuah kelas Animal sebagai base class
class Animal {
  String name;
  Animal(this.name);
  void move() {
    print("$name bergerak.");
  }
}

// Burung yang bisa terbang
class Bird extends Animal with CanFly {
  Bird(String name) : super(name);
}

// Bebek yang bisa terbang dan berenang
class Duck extends Animal with CanFly, CanSwim {
  Duck(String name) : super(name);
}

void main() {
  Bird eagle = Bird("Elang");
  eagle.move();  // dari Animal
  eagle.fly();   // dari CanFly

  Duck mallard = Duck("Mallard");
  mallard.move(); // dari Animal
  mallard.fly();  // dari CanFly
  mallard.swim(); // dari CanSwim
}
```

**Penjelasan Kode:**

* **Baris 1-5:** `mixin CanFly { ... }` – Mendefinisikan sebuah mixin bernama `CanFly`. Mixin ini berisi satu method `fly()` yang mencetak pesan "Terbang melintasi langit!". Kode di dalam mixin bisa dianggap sebagai potongan perilaku yang nantinya dapat disisipkan ke kelas lain.
* **Baris 7-11:** `mixin CanSwim { ... }` – Mendifinisikan mixin lain bernama `CanSwim` dengan satu method `swim()`. Method ini mencetak "Berenang di dalam air!".
* **Baris 14-20:** `class Animal { ... }` – Mendefinisikan kelas `Animal` sebagai kelas dasar dengan sebuah field `name` dan method `move()`. Kelas ini memiliki konstruktor yang menerima `name`. `move()` akan mencetak "<nama> bergerak.". Kelas `Animal` tidak menggunakan mixin apapun, tapi akan menjadi superclass bagi `Bird` dan `Duck`.
* **Baris 23-26:** `class Bird extends Animal with CanFly { ... }` – Mendefinisikan kelas `Bird` yang *extend* (mewarisi) kelas `Animal` dan mencampur (`with`) mixin `CanFly`. Ini berarti `Bird` mewarisi semua yang dimiliki `Animal` **dan** mendapatkan semua kemampuan dari `CanFly`. Kelas `Bird` memiliki konstruktor yang memanggil `super(name)` untuk menginisialisasi bagian `Animal`. Kelas ini tidak mendefinisikan method tambahan, tapi otomatis memiliki method `fly()` karena menggunakan mixin `CanFly`.
* **Baris 29-32:** `class Duck extends Animal with CanFly, CanSwim { ... }` – Kelas `Duck` *extend* `Animal` dan menggunakan **dua mixin**: `CanFly` dan `CanSwim`. Penulisan `with CanFly, CanSwim` berarti `Duck` akan memiliki semua method dari `CanFly` dan `CanSwim` (yakni `fly()` dan `swim()`), selain tentunya mewarisi `move()` dari `Animal`. Konstruktor `Duck` memanggil `super(name)` untuk menginisialisasi `Animal`.
* **Baris 34:** `void main() { ... }` – Fungsi utama program.
* **Baris 35:** `Bird eagle = Bird("Elang");` – Membuat objek `Bird` bernama "Elang". Ini memanggil konstruktor `Bird` (yang pada gilirannya memanggil konstruktor `Animal`). Objek `eagle` sekarang adalah `Animal` yang juga memiliki kemampuan `CanFly`.
* **Baris 36:** `eagle.move();` – Memanggil method `move()` diwarisi dari `Animal`. Output: `"Elang bergerak."`.
* **Baris 37:** `eagle.fly();` – Memanggil method `fly()` yang didapat dari mixin `CanFly`. Output: `"Terbang melintasi langit!"`.
* **Baris 39:** `Duck mallard = Duck("Mallard");` – Membuat objek `Duck` bernama "Mallard". Objek ini adalah `Animal` dengan kemampuan `CanFly` dan `CanSwim`.
* **Baris 40:** `mallard.move();` – Dari `Animal`, mencetak `"Mallard bergerak."`.
* **Baris 41:** `mallard.fly();` – Dari mixin `CanFly`, mencetak `"Terbang melintasi langit!"`.
* **Baris 42:** `mallard.swim();` – Dari mixin `CanSwim`, mencetak `"Berenang di dalam air!"`.

Dari contoh di atas, terlihat bahwa `Bird` dan `Duck` tidak perlu menulis ulang kode untuk terbang atau berenang. Mereka cukup menggunakan mixin yang sesuai. `Duck` bahkan bisa menggunakan dua mixin sekaligus. Ini menunjukkan fleksibilitas mixin dibanding single inheritance biasa.

**Kapan dan Bagaimana Digunakan:**
Mixin digunakan saat Anda ingin menambahkan sekumpulan fitur ke beberapa kelas yang mungkin tidak saling berhubungan dalam hierarki. Contoh praktis: dalam Flutter, *StatefulWidget* menggunakan mixin `TickerProviderStateMixin` untuk mengaktifkan fitur animasi (ticker). Tanpa mixin, kelas `State` mungkin harus mewarisi dari kelas tertentu untuk dapat punya kemampuan ticker, yang menghambat karena Flutter sudah butuh mewarisi `State<T>`. Dengan mixin, `State` bisa tetap mewarisi `State<T>` dan cukup menambahkan `with TickerProviderStateMixin` untuk mendapatkan kemampuan tambahan.

Gunakan mixin ketika Anda punya logic atau method yang sama persis ingin digunakan di banyak kelas berbeda. Misal, Anda membuat beberapa kelas model yang perlu kemampuan untuk logging atau validasi data: buat mixin `Loggable` atau `Validatable` yang dapat di-*mix-in*. Mixin mempromosikan *composition over inheritance* (komposisi ketimbang pewarisan). Karena Dart tidak mendukung pewarisan ganda (multiple inheritance) secara langsung, mixin adalah solusi untuk kasus di mana sifat “ganda” dibutuhkan.

Secara teknis, mixin di Dart dapat digunakan oleh kelas apapun (selama memenuhi syarat, misal mixin tidak punya konstruktor) dengan sintaks `with`. Anda bisa mencampurkan lebih dari satu mixin. Urutan penulisan mixin setelah `with` juga menentukan urutan resolusi jika ada nama method yang sama (mixin yang ditulis terakhir akan override yang sebelumnya jika ada konflik nama).

**Kesalahan Umum Pemula & Cara Menghindarinya:**

* **Menggunakan Mixin Seperti Kelas Biasa:** Pemula kadang mencoba membuat instance dari mixin, misalnya `CanFly birdAbility = CanFly();`, ini tidak diperbolehkan. Mixin bukan kelas konkret, Anda tidak bisa meng-instansiasi mereka. Mixin hanya bisa digunakan via `with` di kelas lain. Untuk menghindari kesalahan ini, ingat bahwa mixin tidak punya konstruktor, sehingga tidak bisa `new MixinName()`.
* **Menambahkan Konstruktor atau `extends` pada Mixin:** Sebagai pemula, mungkin Anda tergoda memberi konstruktor dalam mixin atau meng-extend kelas tertentu di mixin. Dart akan memberikan error karena **mixin tidak boleh punya konstruktor atau extends class** (kecuali menggunakan `mixin <Name> on SomeClass {...}` untuk membatasi penggunaan mixin pada subclass `SomeClass`, tapi itu topik lanjutan). Hindari menulis `extends` di deklarasi mixin, dan definisikan mixin cukup sebagai kumpulan method/field.
* **Konflik Nama Method pada Multiple Mixin:** Jika dua mixin memiliki method dengan nama yang sama dan Anda mencampurkannya ke satu kelas, bisa terjadi konflik. Dart akan memilih implementasi dari mixin yang disebut paling terakhir. Ini bisa membingungkan. Pemula sebaiknya menghindari situasi ini atau konsisten memastikan nama method di mixin berbeda, kecuali memang berniat override.
* **Mengira Mixin Sama dengan Interface:** Dart tidak memiliki kata kunci `interface` (meskipun kelas abstrak bisa berperan sebagai interface). Mixin berbeda dengan sekadar interface karena mixin membawa implementasi konkret yang langsung dipakai oleh kelas penerima. Jangan menggunakan mixin kalau yang Anda butuhkan hanya kontrak method tanpa implementasi – untuk itu cukup gunakan kelas abstrak (atau dengan keyword `abstract interface` di Dart 3).
* **Lupa Menggunakan Keyword `with`:** Kesalahan simpel tapi kerap terjadi, pemula mendefinisikan mixin dengan benar, tapi saat menggunakannya di kelas lupa menulis `with`. Misal menulis `class MyClass extends SomeBase, MyMixin` (dengan koma) mengira itu cara multiple inheritance. Yang benar: gunakan `with MyMixin`. Ingat sintaks-nya khusus: `extends Superclass with MixinA, MixinB`. Jika kelas tidak extends apapun, cukup `class MyClass with MixinA {}` (secara implisit extend `Object`).
* **Tidak Memahami Kapan Gunakan Mixin vs Pewarisan Biasa:** Jika hubungan antara dua kelas adalah *is-a* yang jelas (misal Cat *is an* Animal), gunakan pewarisan (extend). Jika hubungannya adalah memperkaya perilaku (misal Cat ingin bisa terbang - konsep yang aneh dalam hierarki, lebih cocok sebagai kemampuan tambahan), pertimbangkan pakai mixin. Pemula kadang menyalahgunakan mixin untuk hal-hal yang sebetulnya pewarisan umum atau sebaliknya. Pertimbangkan desain: mixin untuk kemampuan *horizontal* (dapat ditambahkan ke banyak kelas berbeda), inheritance untuk relasi *vertikal* yang natural.

## 4. Abstract Class (Kelas Abstrak)

**Konsep Dasar & Tujuan:**
**Kelas abstrak** adalah kelas yang **tidak dapat diinstansiasi menjadi objek** secara langsung, dan biasanya mengandung definisi method yang abstrak (tanpa implementasi) yang harus di-override oleh subclass turunannya. Anda menandai kelas sebagai abstrak dengan keyword `abstract` sebelum deklarasi kelas. Tujuan utama kelas abstrak adalah menjadi **blueprint atau kerangka** bagi kelas lain. Kelas abstrak memungkinkan Anda mendefinisikan *interface* (kumpulan method/properti yang harus dimiliki) sekaligus memberikan implementasi dasar (opsional) yang dapat dipakai atau diubah oleh subclass. Ini mendukung prinsip **abstraction** dalam OOP, di mana detail implementasi disembunyikan dan hanya struktur umum yang diekspos.

Dengan membuat kelas abstrak, Anda memaksa kelas turunannya untuk menerapkan method tertentu, sehingga memastikan konsistensi antarkelas. Contoh: Anda bisa punya kelas abstrak `Shape` dengan method abstrak `area()` dan `perimeter()`. Semua subclass seperti `Circle`, `Rectangle` wajib mengimplementasi kedua method tersebut sesuai rumus masing-masing bentuk, sementara kelas `Shape` mungkin menyediakan implementasi umum lain atau properti umum (misal warna) yang diwarisi semua bentuk.

**Sintaks Umum & Contoh Kode:**
Untuk mendefinisikan kelas abstrak, awali deklarasi dengan `abstract class NamaKelas`. Di dalamnya, Anda bisa mendeklarasikan **abstract method** yang ditandai dengan tidak adanya body (cukup diakhiri `;`). Abstract method **hanya dapat berada di dalam kelas abstrak atau mixin**. Kelas abstrak juga bisa memiliki field dan method **berbodi** (konkrit) seperti kelas biasa. Bedanya, kelas abstrak **tidak bisa dibuat objeknya**. Jika Anda coba `var obj = NamaKelasAbstrak();`, akan error kompilasi.

Sebuah kelas **subclass** dapat *extends* kelas abstrak dan wajib menyediakan implementasi untuk semua abstract method yang diwarisi, kecuali jika subclass itu juga ingin dijadikan abstrak. Berikut contoh:

```dart
abstract class Animal {
  String name;
  Animal(this.name);

  void makeSound(); // abstract method, no body
  void sleep() {
    print("$name sedang tidur... zZz");
  }
}

class Dog extends Animal {
  Dog(String name) : super(name);

  @override
  void makeSound() {
    print("$name: Guk guk!");
  }
}

class Cat extends Animal {
  Cat(String name) : super(name);

  @override
  void makeSound() {
    print("$name: Meong!");
  }
}

void main() {
  // Animal genericAnimal = Animal("Generic"); // SALAH: kelas abstrak tak bisa diinstansiasi
  Dog dog = Dog("Buddy");
  Cat cat = Cat("Mittens");

  dog.makeSound(); // Buddy: Guk guk!
  dog.sleep();     // Buddy sedang tidur... zZz

  cat.makeSound(); // Mittens: Meong!
  cat.sleep();     // Mittens sedang tidur... zZz
}
```

**Penjelasan Kode:**

* **Baris 1-8:** `abstract class Animal { ... }` – Mendefinisikan kelas abstrak bernama `Animal`. Kelas ini punya sebuah field `name` dan sebuah konstruktor `Animal(this.name)` untuk menginisialisasi `name`. Juga terdapat dua method: `makeSound()` dideklarasikan **tanpa body** (diakhiri `;`), artinya ini **method abstrak**. Kemudian ada `sleep()` yang memiliki implementasi (mencetak "`<name> sedang tidur...`"). Karena kelas `Animal` ditandai abstrak, method abstrak di dalamnya diperbolehkan.
* **Baris 3:** `void makeSound();` – Contoh **abstract method**. Tidak ada isi/body, hanya deklarasi. Ini berarti setiap kelas konkret yang extends `Animal` **harus** mengimplementasi `makeSound()`.
* **Baris 4-7:** `void sleep() { ... }` – Contoh method biasa (non-abstrak) dalam kelas abstrak. Subclass `Animal` akan mewarisi implementasi `sleep()` ini apa adanya, tapi bisa *override* jika perlu (tidak wajib karena sudah ada default implementasi).
* **Baris 10-16:** `class Dog extends Animal { ... }` – Mendefinisikan kelas `Dog` sebagai turunan `Animal`. Karena `Animal` punya konstruktor yang butuh `name`, subclass `Dog` menyediakan konstruktor yang memanggil `super(name)` untuk mengisi bagian `Animal`. Kelas `Dog` **harus** override method `makeSound()` yang abstrak, jika tidak, `Dog` juga harus dideklarasikan abstrak.

  * **Baris 13-15:** `@override void makeSound() { ... }` – Implementasi `makeSound()` dalam `Dog`. Di sini diberikan body yang mencetak suara anjing, misalnya "`Buddy: Guk guk!`" (dengan nama anjing). Penggunaan `@override` dianjurkan untuk menandai bahwa method ini adalah implementasi dari yang didefinisikan di superclass.
* **Baris 18-24:** `class Cat extends Animal { ... }` – Kelas `Cat` mirip dengan `Dog`, juga extends `Animal` dan mengimplementasikan `makeSound()` dengan mencetak suara kucing.
* **Baris 27 (komentar):** Contoh kode yang salah: mencoba `Animal genericAnimal = Animal("Generic");`. Ini akan error karena `Animal` adalah abstrak. Baris ini dikomentari untuk menegaskan bahwa Anda tidak bisa membuat objek dari kelas `Animal`. Kelas abstrak hanya bisa diinstantiate melalui subclass konkretnya.
* **Baris 28:** `Dog dog = Dog("Buddy");` – Membuat objek `Dog` bernama "Buddy". Ini legal karena `Dog` adalah kelas konkret (non-abstrak). Konstruktor `Dog` memanggil `Animal("Buddy")` di dalamnya.
* **Baris 29:** `Cat cat = Cat("Mittens");` – Membuat objek `Cat` bernama "Mittens".
* **Baris 31:** `dog.makeSound();` – Memanggil method `makeSound()` pada objek `Dog`. Karena `Dog` override method ini, yang terpanggil adalah implementasi di kelas `Dog`. Output: `"Buddy: Guk guk!"`.
* **Baris 32:** `dog.sleep();` – Memanggil method `sleep()` pada objek `Dog`. Kelas `Dog` tidak override `sleep()`, jadi yang dijalankan adalah implementasi `sleep()` dari kelas `Animal`. Output: `"Buddy sedang tidur... zZz"`.
* **Baris 34-35:** Memanggil `cat.makeSound()` dan `cat.sleep()` dengan hasil serupa untuk objek `Cat`. `makeSound()` menggunakan implementasi `Cat` (output `"Mittens: Meong!"`), `sleep()` pakai bawaan `Animal` (output `"Mittens sedang tidur... zZz"`).

Dari contoh ini, terlihat bagaimana kelas abstrak `Animal` mendefinisikan kerangka: setiap `Animal` harus bisa `makeSound()`, tapi *cara* `makeSound` diserahkan ke masing-masing jenis hewan (anjing menggonggong, kucing mengeong). Namun semua hewan memiliki perilaku tidur yang sama, sehingga `sleep()` cukup didefinisikan sekali di `Animal`. Pola ini umum di OOP: kelas abstrak mendefinisikan *template method* yang harus diisi subclass, sekaligus memberikan implementasi standar untuk hal lain.

**Kapan dan Bagaimana Digunakan:**
Gunakan kelas abstrak ketika Anda ingin membuat kelas dasar yang tidak layak diinstansiasi sendiri, melainkan untuk diwarisi oleh kelas lain. Biasanya kelas abstrak merepresentasikan konsep general yang baru berguna saat dibuat spesifik di subclass. Contoh:

* Dalam aplikasi grafis, Anda mungkin punya abstract class `Shape` dengan method abstrak `draw()` dan `resize()`. Subclass `Circle`, `Rectangle` dll. akan implementasi kedua method tersebut berbeda-beda.
* Dalam Flutter, banyak kelas dalam framework bersifat abstrak. Misalnya class `State<T>` adalah abstrak; Anda harus membuat subclass `MyHomePageState` extends `State<MyHomePage>` dan implementasi method build(). Contoh lain, `WidgetsBindingObserver` memiliki sejumlah method callback abstrak yang bisa dioverride oleh subclass untuk merespon event aplikasi.

Kelas abstrak juga bisa digunakan sebagai **interface** di Dart. Dart tidak punya keyword `interface` terpisah; secara default setiap kelas (termasuk abstrak) dapat dianggap interface, dan Anda bisa `implements` kelas tersebut di kelas lain. Jika sebuah kelas abstrak hanya berisi deklarasi tanpa implementasi apapun (semua method abstrak), itu mirip interface murni. Sejak Dart 3, ada modifier `interface` dan `abstract interface` untuk menekankan hal ini, tapi konsep dasarnya sama.

**Kesalahan Umum Pemula & Cara Menghindarinya:**

* **Mencoba Menginstansiasi Kelas Abstrak:** Seperti dijelaskan, ini tidak diperbolehkan. Pesan error-nya biasanya *“Cannot instantiate abstract class”*. Selalu buat subclass konkret lalu instansiasi subclass tersebut. Jika Anda merasa perlu menginstansiasi kelas abstrak, mungkin desain Anda perlu ditinjau ulang – apakah kelas itu seharusnya abstrak?
* **Lupa Override Method Abstrak di Subclass:** Jika subclass extends kelas abstrak tapi tidak mengimplementasikan semua method abstraknya, Anda akan mendapat error kompilasi (kecuali menjadikan subclass itu abstrak juga). Pemula kadang membuat subclass tapi lupa satu method abstrak, lalu bingung dengan error. Solusinya, baca pesan errornya, lalu tambahkan override untuk setiap method abstrak yang diminta. IDE biasanya dapat membantu dengan auto-generate override stubs.
* **Tidak Menandai Override:** Meskipun tidak menambahkan `@override` tidak menyebabkan error (selama signaturenya cocok), sangat disarankan menulis anotasi `@override` saat mengimplementasi method abstrak. Ini membantu memastikan bahwa Anda benar-benar mengoverride method yang dimaksud (seringkali, typo pada nama atau tipe parameter bisa bikin method Anda dianggap baru, bukan override). Gunakan fitur auto-complete IDE untuk menghindari kesalahan penulisan.
* **Membuat Kelas Seharusnya Abstrak Menjadi Kelas Biasa:** Jika Anda memiliki kelas dasar yang tidak masuk akal untuk dibuat objek langsung, jadikanlah abstrak. Pemula kadang membuat kelas normal padahal hanya digunakan sebagai induk. Misal kelas `Employee` dengan method abstrak `calculateSalary()` seharusnya ditandai abstract. Akibatnya, mungkin ada yang tanpa sengaja instantiate `Employee`, yang secara logika rancu. Evaluasi desain: bila sebuah kelas dirancang untuk diperluas saja, beri `abstract`.
* **Menggunakan Kelas Abstrak di Tempat yang Salah:** Kelas abstrak biasanya berada di puncak hierarki atau di dekat puncak. Jangan ragu menggunakan kelas abstrak untuk memisahkan definisi *versus* implementasi. Tapi pemula kadang terlalu bersemangat membuat banyak kelas abstrak tanpa kebutuhan jelas. Abstraksi berlebih bisa membuat kode rumit. Pastikan Anda membuat abstraksi yang memudahkan, bukan mempersulit. Mulailah dari kebutuhan: jika beberapa kelas butuh interface yang sama, naikkan ke abstrak. Jika tidak, jangan paksa abstrak.
* **Bingung Antara `extends` dan `implements`:** Jika Anda `extends` kelas abstrak, Anda mewarisi implementasi yang ada (dan harus isi yang abstrak). Jika Anda `implements` sebuah kelas (bisa abstrak atau konkret), Anda tidak mewarisi implementasi apapun, Anda hanya berjanji untuk menyediakan implementasi semua method (bahkan yang sudah berbody di kelas aslinya harus Anda tulis ulang). Pemula terkadang salah pilih antara extends vs implements. Aturan mudah: gunakan `extends` untuk memperluas kelas abstrak yang mungkin sudah punya beberapa logic umum; gunakan `implements` jika Anda hanya butuh kontraknya saja dan akan menulis semua dari nol (ini serupa interface di bahasa lain).

## 5. Terse Style dengan Typedefs

**Konsep Dasar & Tujuan:**
Istilah *"terse style"* merujuk pada gaya penulisan kode yang **ringkas dan jelas**. Dalam Dart, salah satu alat bantu untuk menulis kode secara ringkas adalah **typedef (type definition)**. **Typedef** digunakan untuk membuat alias (nama lain) untuk tipe tertentu, sehingga Anda dapat mengacu ke tipe tersebut dengan nama yang lebih pendek atau lebih bermakna. Ini sangat bermanfaat terutama untuk tipe yang kompleks atau fungsi dengan definisi panjang. Dengan typedef, kode menjadi lebih singkat dan mudah dibaca karena Anda **menghindari pengulangan penulisan tipe yang panjang**. Typedef juga bisa memberikan konteks atau semantik pada suatu tipe. Misalnya, Anda bisa membuat alias `typedef UserId = String;` sehingga ketika melihat kode, `UserId` lebih informatif daripada sekadar `String`.

Sebelum Dart 2.13, `typedef` hanya bisa dibuat untuk tipe fungsi. Namun sejak Dart 2.13, typedef dapat mewakili **tipe apapun**, tidak hanya fungsi. Meski begitu, penggunaan utamanya tetap pada alias untuk tipe fungsi (fungsi callback, signature tertentu) dan alias untuk tipe generik kompleks, agar kode lebih *terse* (ringkas).

**Sintaks Umum & Contoh Kode:**
Sintaks `typedef` ada dua bentuk:

* **Untuk fungsi (new syntax):** `typedef AliasName = ReturnType Function(Type1 param1, Type2 param2, ...);`
  Contoh: `typedef IntBinaryOp = int Function(int, int);` mendefinisikan `IntBinaryOp` sebagai alias untuk tipe fungsi yang menerima dua `int` dan mengembalikan `int`.
* **Untuk tipe non-fungsi:** `typedef AliasName = ExistingType;`
  Contoh: `typedef IntList = List<int>;` mendefinisikan `IntList` sebagai alias untuk `List<int>`.

Anda kemudian dapat menggunakan `AliasName` tersebut di kode seolah-olah itu tipe asli. Di bawah ini, kita buat beberapa typedef dan gunakan mereka:

```dart
typedef IntList = List<int>;
typedef Operation = int Function(int, int);

// Fungsi yang sesuai dengan tipe Operation
int add(int a, int b) => a + b;
int multiply(int x, int y) => x * y;

void main() {
  // Menggunakan alias IntList
  IntList numbers = [1, 2, 3, 4];
  print(numbers is List<int>);    // true (IntList sebenarnya List<int>)
  print(numbers.length);          // Output: 4

  // Menggunakan alias Operation
  Operation op;
  op = add;
  print(op(3, 4));               // Output: 7 (menggunakan fungsi add melalui alias)
  op = multiply;
  print(op(3, 4));               // Output: 12 (menggunakan fungsi multiply melalui alias)

  // Contoh typedef untuk memberikan konteks
  typedef UserId = String;
  UserId myId = "USR12345";
  print(myId.replaceAll("USR", "ID_"));  // Output: ID_12345
}
```

**Penjelasan Kode:**

* **Baris 1:** `typedef IntList = List<int>;` – Mendefinisikan alias **IntList** untuk tipe `List<int>`. Setelah ini, Anda bisa menggunakan `IntList` sebagai pengganti `List<int>` di kode. Ini membuat penulisan lebih singkat, terutama jika tipe aslinya panjang.
* **Baris 2:** `typedef Operation = int Function(int, int);` – Mendefinisikan alias **Operation** untuk tipe fungsi yang menerima dua `int` dan mengembalikan `int`. Jadi `Operation` mewakili "tipe fungsi biner yang menghasilkan int".
* **Baris 5-6:** Dua fungsi `add` dan `multiply` didefinisikan, masing-masing menjumlahkan dan mengalikan dua bilangan. Keduanya memiliki tipe yang cocok dengan alias `Operation` (yaitu `int Function(int,int)`).
* **Baris 9:** `void main() { ... }` – Fungsi utama.
* **Baris 11:** `IntList numbers = [1, 2, 3, 4];` – Menggunakan alias `IntList` yang kita buat untuk mendeklarasikan list of int. Ini setara dengan menulis `List<int> numbers = [1,2,3,4];`. Variabel `numbers` berisi list `[1,2,3,4]`.
* **Baris 12:** `print(numbers is List<int>);` – Mengecek dengan operator `is` apakah `numbers` merupakan `List<int>`. Ini akan mencetak `true`, membuktikan bahwa di balik alias, `IntList` memang `List<int>`. Alias tidak membuat tipe baru di runtime; ia hanya nama lain di level kode.
* **Baris 13:** `print(numbers.length);` – Menunjukkan penggunaan `numbers` seperti list biasa. Output: `4` karena list tersebut berisi 4 elemen.
* **Baris 16:** `Operation op;` – Mendeklarasikan variabel `op` bertipe alias `Operation`. Artinya `op` dapat menampung referensi ke fungsi apapun yang sesuai dengan signature `int Function(int,int)`.
* **Baris 17:** `op = add;` – Mengisi `op` dengan fungsi `add`. Ini diperbolehkan karena `add` memiliki tipe yang sesuai alias `Operation`.
* **Baris 18:** `print(op(3, 4));` – Memanggil fungsi melalui variabel `op`. Karena `op` saat ini menunjuk ke `add`, maka ini ekuivalen dengan memanggil `add(3,4)`. Output: `7`.
* **Baris 19:** `op = multiply;` – Sekarang `op` diisi dengan fungsi `multiply`. Kembali, tipe cocok sehingga boleh.
* **Baris 20:** `print(op(3, 4));` – Memanggil `op(3,4)` lagi, tetapi kini `op` mengarah ke `multiply`. Hasilnya `12`. Contoh ini menggambarkan bagaimana typedef mempermudah penggunaan fungsi sebagai first-class object dengan lebih jelas. Tanpa typedef, kita harus menulis tipe lengkap `int Function(int,int)` setiap kali, yang lebih panjang. Dengan `Operation`, kode lebih rapi.
* **Baris 23-25:** Contoh tambahan membuat alias `UserId` untuk `String`. Lalu mendeklarasikan `myId` bertipe `UserId` dan mengisinya dengan sebuah string `"USR12345"`. Memanggil method string `replaceAll` pada `myId` tetap bisa dilakukan, karena di runtime `UserId` hanyalah `String`. Output: `ID_12345`. Contoh ini menunjukkan typedef juga bisa meningkatkan **pemberian konteks**: daripada pakai `String` generik, menggunakan `UserId` membuat kode lebih *self-descriptive* (menjelaskan maksud variabel tersebut adalah ID user).

**Kapan dan Bagaimana Digunakan:**
Typedef utamanya digunakan untuk:

* **Function Callbacks:** Dalam Flutter, misalnya, banyak widget yang menerima parameter callback dengan tipe fungsi tertentu. Sering didefinisikan typedef untuk itu. Contoh: `typedef VoidCallback = void Function();` adalah alias untuk fungsi tanpa parameter yang tidak return (biasa dipakai untuk onPressed, dsb). Dengan adanya `VoidCallback`, deklarasi fungsi menjadi lebih bersih daripada menulis `void Function()` setiap kali.
* **Complex Generic Types:** Jika Anda memiliki tipe generik panjang, typedef dapat meringkasnya. Misal alih-alih menulis berkali-kali `Map<String, List<Map<int, String>>>`, Anda bisa buat `typedef MyData = Map<String, List<Map<int, String>>>;` lalu cukup pakai `MyData`. Ini meningkatkan keterbacaan. Contoh di dokumentasi: `typedef ListMapper<X> = Map<X, List<X>>;` sehingga `ListMapper<String>` lebih jelas ketimbang `Map<String, List<String>>`.
* **Semantic Type Aliases:** Seperti contoh `UserId = String` di atas, atau `Timestamp = int`. Walaupun ini tidak menambah tipe baru secara nyata (alias bukan subclass atau tipe distinct), ini membantu pembaca kode memahami maksud variabel tersebut. Ini semacam dokumentasi inline.

Ketika menggunakan typedef, pastikan nama aliasnya mencerminkan peran tipe tersebut. Penulisan nama typedef biasanya **PascalCase** seperti nama kelas. Gunakan typedef saat Anda merasa tipe suatu deklarasi terlalu panjang/rumit dan muncul berulang kali, atau saat Anda ingin memberikan nama khusus yang lebih komunikatif.

**Kesalahan Umum Pemula & Cara Menghindarinya:**

* **Mengira Typedef Membuat Tipe Baru Sepenuhnya:** Penting dipahami bahwa typedef hanyalah alias/sinonim, **bukan** kelas/tipe baru pada runtime. Artinya, `UserId` dalam contoh di atas diperlakukan sama seperti `String`. Anda tidak bisa, misalnya, memperlakukan `UserId` berbeda dengan `String` di runtime atau meng-extend alias. Pemula kadang berharap bisa menambahkan method khusus ke typedef (tidak bisa, kecuali menggunakan extension method pada tipe aslinya). Solusinya, gunakan typedef hanya untuk mempersingkat penulisan, bukan untuk membuat konsep tipe berbeda.
* **Tersesat dengan Typedef Lama vs Baru:** Sumber belajar lama mungkin menunjukkan sintaks typedef untuk fungsi seperti `typedef IntOperation(int a, int b);` (gaya sebelum Dart 2.13). Itu sebenarnya mendefinisikan alias untuk fungsi juga, namun dengan sintaks berbeda. Sekarang disarankan menggunakan format `typedef IntOperation = int Function(int, int);`. Pemula mungkin bingung melihat dua gaya ini. Cara menghindarinya, ikuti dokumentasi terbaru; ketahuilah bahwa keduanya intinya sama, hanya sintaks berbeda.
* **Tidak Menggunakan Typedef Saat Tipe Terlalu Panjang:** Ini kebalikan dari kesalahan – bukan error, tapi kesempatan yang terlewat. Misal Anda menulis tipe fungsi kompleks berulang kali di beberapa tempat. Jika pemula tidak tahu typedef, kodenya jadi verbose. Solusinya, selalu ingat fitur ini tersedia. Begitu Anda melihat pola tipe panjang berulang, pertimbangkan buat typedef agar kode lebih *dry* (Don't Repeat Yourself).
* **Menamai Alias Terlalu Umum:** Karena typedef menciptakan nama tipe baru di level kode, jangan berikan nama yang bisa bentrok atau rancu dengan kelas/tipe lain. Misal jangan buat typedef `List = List<int>` (ini akan membingungkan parser dan programmer lain). Gunakan nama yang spesifik dan jelas tujuannya.
* **Lupa Bahwa Typedef Juga Bisa Generic:** Anda bisa membuat typedef dengan parameter generik, namun pemula mungkin tidak memanfaatkannya. Misal `typedef JsonMap<T> = Map<String, T>;` dapat memperumum alias untuk berbagai tipe nilai. Jika Anda perlu hal semacam itu, jangan buat banyak alias mirip, cukup gunakan parameter generik. Hindari menduplikasi typedef hanya karena tipe dalamnya beda tipis; gunakan kemampuan generik pada typedef.
* **Menempatkan Typedef di Lokasi Kurang Tepat:** Idealnya, kumpulkan typedef (terutama untuk callback atau tipe publik) di bagian atas file atau di satu file terpisah (misal `typedefs.dart`) jika digunakan di banyak tempat. Pemula kadang mendefinisikan typedef di dalam fungsi atau kelas tanpa alasan jelas – itu boleh (typedef bisa didefinisikan di scope lokal), tapi jarang dibutuhkan. Biasanya typedef berada di level top-level (global) agar bisa diimport dan digunakan lintas file.

## Referensi

1. **Classes – Dart Language Tour** (dart.dev). Penjelasan mengenai kelas, objek, dan pewarisan berbasis mixin dalam bahasa Dart.
2. **Sound Null Safety** – Dart Documentation (dart.dev). Ikhtisar null safety: semua variabel non-nullable secara default, mencegah error runtime akibat `null`.
3. **Mixins – Dart Language** (dart.dev). Konsep dan contoh penggunaan mixin untuk reuse kode di berbagai hierarki kelas.
4. **Class Modifiers (abstract)** – Dart Language (dart.dev). Keterangan bahwa kelas abstrak tidak dapat diinstansiasi dan sering mengandung method abstrak.
5. **Typedefs (Type Aliases)** – Dart Language (dart.dev). Cara membuat alias tipe dengan `typedef`, contoh alias untuk koleksi dan fungsi.
6. **Andrea Bizzotto, "How to Define Type Aliases in Dart"** (codewithandrea.com, 2024). Artikel singkat yang menjelaskan manfaat typedef dalam membuat kode lebih ringkas dan mudah dibaca.
